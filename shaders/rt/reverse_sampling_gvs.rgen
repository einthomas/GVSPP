int reverseSampling(uint launchIndex, Vertex v[3], Sample s, vec3 rayOrigin, vec3 rayDir, int occludingTriangleID, vec3 samplePos, vec3 hitPoint) {
    int foundSampleIndex = -1;
    if (occludingTriangleID != -1) {
        // Check for discontinuity
        // Intersect ray with the plane of the original triangle
        vec3 planeNormal = normalize(cross(v[1].worldPos - v[0].worldPos, v[2].worldPos - v[0].worldPos));
        vec3 predictedHitPoint = vec3(0.0f);
        if (
            intersectRayPlane(v[0].worldPos, planeNormal, rayOrigin, rayDir, predictedHitPoint) &&
            length(predictedHitPoint - rayOrigin) - length(hitPoint - rayOrigin) > 0.985
        ) {
            // Get view cell coordinate system
            vec3 viewCellSize = vec3(
                length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
                length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
                length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
            ) * 2.0f;
            vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
            vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
            vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
            if (viewCellSize.x == 0.0f) {
                viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
            } else if (viewCellSize.y == 0.0f) {
                viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
            } else if (viewCellSize.z == 0.0f) {
                //viewCellRight = -viewCellRight;
                viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
            }
            vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

            #ifdef USE_3D_VIEW_CELL
                const vec3 faceRights[6] = { viewCellRight, -viewCellNormal, -viewCellRight, viewCellNormal, viewCellRight, viewCellRight };
                const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCellNormal, viewCellNormal };
                const vec3 faceNormals[6] = { viewCellNormal, viewCellRight, -viewCellNormal, -viewCellRight, viewCellUp, -viewCellUp };
                const vec3 faceSizes[6] = { viewCellSize.xyz, viewCellSize.zyx, viewCellSize.xyz, viewCellSize.zyx, viewCellSize.xzy, viewCellSize.xzy };
            #endif

            // Construct plane though the ray origin, the hit point of the original triangle and the
            // hit point of the new triangle
            planeNormal = normalize(cross(s.rayHitPos - rayOrigin, hitPoint - rayOrigin));
            vec3 planePoint = rayOrigin;

            // Get the vertices of the intersected, closer triangle
            Vertex v0 = unpackVertexData(indices.i[3 * occludingTriangleID]);
            Vertex v1 = unpackVertexData(indices.i[3 * occludingTriangleID + 1]);
            Vertex v2 = unpackVertexData(indices.i[3 * occludingTriangleID + 2]);

            // Choose the two vertices that are on the same side of the plane
            bool vertexSide[3] = {
                dot(planeNormal, v0.worldPos - planePoint) > 0,
                dot(planeNormal, v1.worldPos - planePoint) > 0,
                dot(planeNormal, v2.worldPos - planePoint) > 0
            };
            Vertex a, b, c;
            if (vertexSide[0] == vertexSide[1]) {
                a = v0;
                b = v1;
                c = v2;
            } else if (vertexSide[0] == vertexSide[2]) {
                a = v0;
                b = v2;
                c = v1;
            } else if (vertexSide[1] == vertexSide[2]) {
                a = v1;
                b = v2;
                c = v0;
            }

            // Construct a line between the two vertices on the same side of the plane each and the vertex on
            // the opposite side and intersect them with the plane
            vec3 p0;
            vec3 p1;
            if (
                intersectRayPlane(planePoint, planeNormal, a.worldPos, normalize(c.worldPos - a.worldPos), p0) &&
                intersectRayPlane(planePoint, planeNormal, b.worldPos, normalize(c.worldPos - b.worldPos), p1)
            ) {
                // Construct points along the intersection line right outside of the triangle (on both sides)
                const int numPointOutsideTriangle = 2;
                vec3 pointOutsideTriangle[numPointOutsideTriangle];
                pointOutsideTriangle[0] = p0 + normalize(p0 - p1) * 0.01;
                pointOutsideTriangle[1] = p1 + normalize(p1 - p0) * 0.01;

                /*
                // More sample points outside the occluding triangle
                const int numPointOutsideTriangle = 16;
                vec3 pointOutsideTriangle[numPointOutsideTriangle];
                for (int i = 0; i < 8; i++) {
                    pointOutsideTriangle[i] = p0 + normalize(p0 - p1) * (10.0 / float((i + 1) * (i + 1)));
                    pointOutsideTriangle[i + 8] = p1 + normalize(p1 - p0) * (10.0 / float((i + 1) * (i + 1)));
                }
                */

                // Intersect a ray through the predicted hit point and the points just outside the triangle, each, with
                // the view cell
                vec3 rayViewCellHitPoint;
                for (int k = 0; k < numPointOutsideTriangle; k++) {
                    vec3 rayDir = normalize(pointOutsideTriangle[k] - predictedHitPoint);

                    #ifdef USE_3D_VIEW_CELL
                        for (int m = 0; m < 6; m++) {
                            if (dot(rayDir, faceNormals[m]) < 0) {
                                continue;
                            }

                            viewCellNormal = faceNormals[m];
                            viewCellRight = faceRights[m];
                            viewCellUp = faceUps[m];
                            viewCellSize = faceSizes[m];
                            viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]) + viewCellNormal * viewCellSize.z * 0.5;
                    #endif

                    // Check if the ray through the point right outside of the triangle and the predicted hit point
                    // intersects the view cell
                    if (!intersectRayPlane(viewCellPos, viewCellNormal, pointOutsideTriangle[k], rayDir, rayViewCellHitPoint)) {
                        continue;
                    }

                    vec3 s0 = viewCellPos - viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;
                    vec3 s1 = viewCellPos + viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;
                    vec3 s2 = viewCellPos - viewCellRight * viewCellSize.x * 0.5 - viewCellUp * viewCellSize.y * 0.5;

                    // Check if the ray-plane hit point lies within the bounds of the view cell
                    // Project ray-plane hit point on local basis of the view cell
                    float u = dot(rayViewCellHitPoint - s0, s1 - s0);
                    float v = dot(rayViewCellHitPoint - s0, s2 - s0);

                    // Check if the u & v coordinates are within the view cell
                    if (u >= 0.0 && v >= 0.0 && u <= dot(s1 - s0, s1 - s0) && v <= dot(s2 - s0, s2 - s0)) {
                        rayDir = -rayDir;
                        rayOrigin = rayViewCellHitPoint;

                        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                        tracedRsRays++;

                        int triangleID = int(hitInfo.w);
                        if (triangleID != -1) { // && isTriangleFrontFacing(viewCellNormal, viewCellPos, triangleID)) {
                            uint index = storeReverseSample(
                                launchIndex,
                                Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos),
                                samplePos
                            );
                            if (length(hitInfo.xyz - samplePos) < 0.01) {
                                foundSampleIndex = int(index);
                            }
                        }
                    }
                    #ifdef USE_3D_VIEW_CELL
                        }
                    #endif
                }
            }
        }
    }

    return foundSampleIndex;
}

bool reverseSampling(uint launchIndex, vec3 v[3], Sample s, vec3 rayOrigin, vec3 rayDir, int occludingTriangleID, vec3 samplePos, vec3 hitPoint, out Sample foundSample) {
    bool discontinuityFound = false;
    if (occludingTriangleID != -1) {
        // Check for discontinuity
        // Intersect ray with the plane of the original triangle
        vec3 planeNormal = normalize(cross(v[1] - v[0], v[2] - v[0]));
        vec3 predictedHitPoint = vec3(0.0f);
        const float samplePointDistance = length(samplePos - rayOrigin);
        vec3 startRayDir = rayDir;
        if (
            intersectRayPlane(v[0], planeNormal, rayOrigin, rayDir, predictedHitPoint) &&
            samplePointDistance - length(hitPoint - rayOrigin) > 0.985
        ) {
            foundSample.triangleID = -2;
            discontinuityFound = true;

            vec3 viewCellSize = viewCell.size * 2.0f;
            vec3 viewCellRight = viewCell.right;
            vec3 viewCellUp = viewCell.up;
            vec3 viewCellNormal = viewCell.normal;
            vec3 viewCellPos = viewCell.pos;

            #ifdef USE_3D_VIEW_CELL
                const vec3 faceRights[6] = { viewCellRight, -viewCellNormal, -viewCellRight, viewCellNormal, viewCellRight, viewCellRight };
                const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCellNormal, viewCellNormal };
                const vec3 faceNormals[6] = { viewCellNormal, viewCellRight, -viewCellNormal, -viewCellRight, viewCellUp, -viewCellUp };
                const vec3 faceSizes[6] = { viewCellSize.xyz, viewCellSize.zyx, viewCellSize.xyz, viewCellSize.zyx, viewCellSize.xzy, viewCellSize.xzy };
            #endif

            // Construct plane though the ray origin, the hit point of the original triangle and the
            // hit point of the new triangle
            planeNormal = normalize(cross(s.rayHitPos - rayOrigin, hitPoint - rayOrigin));
            vec3 planePoint = rayOrigin;

            // Get the vertices of the intersected, closer triangle
            /*
            Vertex v0 = unpackVertexData(indices.i[3 * occludingTriangleID]);
            Vertex v1 = unpackVertexData(indices.i[3 * occludingTriangleID + 1]);
            Vertex v2 = unpackVertexData(indices.i[3 * occludingTriangleID + 2]);
            */
            const vec3 v0WorldPos = getVertexPos(indices.i[3 * occludingTriangleID]);
            const vec3 v1WorldPos = getVertexPos(indices.i[3 * occludingTriangleID + 1]);
            const vec3 v2WorldPos = getVertexPos(indices.i[3 * occludingTriangleID + 2]);

            // Choose the two vertices that are on the same side of the plane
            bool vertexSide[3] = {
                dot(planeNormal, v0WorldPos - planePoint) > 0,
                dot(planeNormal, v1WorldPos - planePoint) > 0,
                dot(planeNormal, v2WorldPos - planePoint) > 0
            };
            vec3 a, b, c;
            if (vertexSide[0] == vertexSide[1]) {
                a = v0WorldPos;
                b = v1WorldPos;
                c = v2WorldPos;
            } else if (vertexSide[0] == vertexSide[2]) {
                a = v0WorldPos;
                b = v2WorldPos;
                c = v1WorldPos;
            } else if (vertexSide[1] == vertexSide[2]) {
                a = v1WorldPos;
                b = v2WorldPos;
                c = v0WorldPos;
            }

            // Construct a line between the two vertices on the same side of the plane each and the vertex on
            // the opposite side and intersect them with the plane
            vec3 p0;
            vec3 p1;
            float t0;
            float t1;
            if (
                intersectRayPlane2(planePoint, planeNormal, a, normalize(c - a), p0, t0) &&
                intersectRayPlane2(planePoint, planeNormal, b, normalize(c - b), p1, t1)
            ) {
                // Construct points along the intersection line right outside of the triangle (on both sides)
                const int numPointOutsideTriangle = 2;
                vec3 pointOutsideTriangle[numPointOutsideTriangle];
                pointOutsideTriangle[0] = p0 + normalize(p0 - p1) * 0.01;
                //pointOutsideTriangle[0] = p0 + (p0 - p1) * t0;
                //pointOutsideTriangle[0] += normalize(pointOutsideTriangle[0] - samplePos);
                pointOutsideTriangle[1] = p1 + normalize(p1 - p0) * 0.01;
                //pointOutsideTriangle[1] = p1 + (p1 - p0) * t1;
                //pointOutsideTriangle[1] += normalize(pointOutsideTriangle[1] - samplePos);

                /*
                // More sample points outside the occluding triangle
                const int numPointOutsideTriangle = 16;
                vec3 pointOutsideTriangle[numPointOutsideTriangle];
                for (int i = 0; i < 8; i++) {
                    pointOutsideTriangle[i] = p0 + normalize(p0 - p1) * (10.0 / float((i + 1) * (i + 1)));
                    pointOutsideTriangle[i + 8] = p1 + normalize(p1 - p0) * (10.0 / float((i + 1) * (i + 1)));
                }
                */

                // Intersect a ray through the predicted hit point and the points just outside the triangle, each, with
                // the view cell
                vec3 rayViewCellHitPoint;
                for (int k = 0; k < numPointOutsideTriangle; k++) {
                    vec3 rayDir = normalize(pointOutsideTriangle[k] - predictedHitPoint);
                    if (dot(-rayDir, viewCellNormal) < 0) {
                        continue;
                    }

                    #ifdef USE_3D_VIEW_CELL
                        for (int m = 0; m < 6; m++) {
                            if (dot(startRayDir, faceNormals[m]) < 0) {
                                continue;
                            }

                            viewCellNormal = faceNormals[m];
                            viewCellRight = faceRights[m];
                            viewCellUp = faceUps[m];
                            viewCellSize = faceSizes[m];
                            viewCellPos = viewCell.pos + viewCellNormal * viewCellSize.z * 0.5;
                    #endif

                    // Check if the ray through the point right outside of the triangle and the predicted hit point
                    // intersects the view cell
                    if (!intersectRayPlane(viewCellPos, viewCellNormal, pointOutsideTriangle[k], rayDir, rayViewCellHitPoint)) {
                        continue;
                    }

                    vec3 s0 = viewCellPos - viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;
                    vec3 s1 = viewCellPos + viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;
                    vec3 s2 = viewCellPos - viewCellRight * viewCellSize.x * 0.5 - viewCellUp * viewCellSize.y * 0.5;

                    // Check if the ray-plane hit point lies within the bounds of the view cell
                    // Project ray-plane hit point on local basis of the view cell
                    float u = dot(rayViewCellHitPoint - s0, s1 - s0);
                    float v = dot(rayViewCellHitPoint - s0, s2 - s0);

                    // Check if the u & v coordinates are within the view cell
                    if (u >= 0.0 && v >= 0.0 && u <= dot(s1 - s0, s1 - s0) && v <= dot(s2 - s0, s2 - s0)) {
                        rayDir = -rayDir;
                        rayOrigin = rayViewCellHitPoint;

                        traceNV(topLevelAS, gl_RayFlagsCullBackFacingTrianglesNV | gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                        atomicAdd(rsRayCounter, 1);

                        int triangleID = int(hitInfo.w);
                        if (triangleID != -1) {
                            bool targetSampleReached = (length(hitInfo.xyz - rayOrigin) - samplePointDistance >= 0.0f) && (foundSample.triangleID == -2);
                            if (targetSampleReached) {
                                foundSample = Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos);
                            }
                            int index = storeReverseSample(
                                launchIndex,
                                Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos),
                                targetSampleReached
                            );
                        }
                    }
                    #ifdef USE_3D_VIEW_CELL
                        }
                    #endif
                }
            }
        }
    }

    return discontinuityFound;
}

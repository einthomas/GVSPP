#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec3 size;
    vec3 normal;
    vec3 tilePos;
    vec3 tileSize;
} viewCell;
layout(binding = 6, set = 0) writeonly buffer randomSamplingOutputBuffer {
    Sample randomSamplingOutput[];
};
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

layout(push_constant) uniform PushConstants {
	int faceIndices[7];  // faceIndices[0] stores the number of faces
} pushConstants;


layout(binding = 9, set = 0) buffer testBuffer {        // PVS
    int test[];
};

layout(binding = 10, set = 0) writeonly buffer randomSamplingOutputIDbuffer {
    int triangleIDOutput[];
};

layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;

void main() {
    // Calculate 1D launch index
    uint launchIndex = gl_LaunchIDNV.x;

    // Construct view cell coordinate system
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 viewCellRight = normalize(cross(viewCell.normal, up));     // TODO: Doesn't work if the viewcell normal is also (0, 1, 0)!
    vec3 viewCellUp = normalize(cross(viewCellRight, viewCell.normal));
    vec3 viewCellPos = viewCell.tilePos;
    vec3 viewCellNormal = viewCell.normal;
    vec3 viewCellSize = viewCell.tileSize;

    #ifdef USE_3D_VIEW_CELL
        //int index = int(launchIndex / int(gl_LaunchSizeNV.x / float(pushConstants.faceIndices[0])));
        int index = int(launchIndex / int(gl_LaunchSizeNV.x / 6.0f));
        index = index > pushConstants.faceIndices[0] - 1 ? index - 1 : index;
        index += 1;
        const int faceIndex = pushConstants.faceIndices[index];
        
        const vec3 faceNormals[6] = { viewCell.normal, viewCellRight, -viewCell.normal, -viewCellRight, viewCellUp, -viewCellUp };
        const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCell.normal, viewCell.normal };
        const vec3 faceRights[6] = { viewCellRight, -viewCell.normal, -viewCellRight, viewCell.normal, viewCellRight, viewCellRight };

        viewCellNormal = faceNormals[faceIndex];
        viewCellRight = faceRights[faceIndex];
        viewCellUp = faceUps[faceIndex];
        viewCellPos = viewCell.pos + viewCellNormal * viewCell.size * 0.5;
        viewCellSize = viewCell.size;
    #endif

    vec3 rayOrigin;
    vec3 rayDir;

    // Map Halton point to point on view cell
    vec2 haltonPoint = vec2(points[launchIndex * 4], points[launchIndex * 4 + 1]);
    vec2 offset = (haltonPoint - vec2(0.5)) * viewCellSize.xy;
    rayOrigin = viewCellPos + offset.x * viewCellRight + offset.y * viewCellUp;

    // Use a different Halton point to calculate the ray direction
    haltonPoint = vec2(points[launchIndex * 4 + 2], points[launchIndex * 4 + 3]);

    // Map Halton point to point on hemisphere
    float phi = 2.0 * 3.1415926 * haltonPoint.x;
    float r = sqrt(max(1.0 - haltonPoint.y * haltonPoint.y, 0.0));
    rayDir = vec3(r * cos(phi), r * sin(phi), haltonPoint.y);

    // Transform direction to view cell coordinate system
    rayDir = normalize(rayDir.x * viewCellRight + rayDir.y * viewCellUp + rayDir.z * viewCellNormal);

    // Trace ray
    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    traceNV(
        topLevelAS,     // acceleration structure
        rayFlags,       // rayFlags
        cullMask,       // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        rayOrigin.xyz,  // ray origin
        tmin,           // ray min range
        rayDir.xyz,     // ray direction
        tmax,           // ray max range
        0               // payload (location = 0)
    );
    
    if (int(hitInfo.w) != -1) {
        uint index = atomicAdd(triangleCounter, 1);
        triangleIDOutput[index] = int(hitInfo.w);
        randomSamplingOutput[index] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, hitInfo.xyz);
    }
}

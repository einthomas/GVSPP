#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    mat4 model;
} viewCell;
layout(binding = 6, set = 0) writeonly buffer randomSamplingOutputBuffer {
    Sample randomSamplingOutput[];
};
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
    uint pvsSize;
};

layout(binding = 9, set = 0) buffer setBuffer {
    int set[];
};

layout(binding = 10, set = 0) uniform pvsBufferCapacity {
    int pvsCapacity;
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

#include "gpuHashSet.glsl"

void main() {
    // Calculate 1D launch index
    uint launchIndex = gl_LaunchIDNV.x;

    // Get view cell coordinate system
    vec3 viewCellSize = vec3(
        length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
        length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
        length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
    ) * 2.0f;
    vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
    vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
    vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
    if (viewCellSize.x == 0.0f) {
        viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
    } else if (viewCellSize.y == 0.0f) {
        viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
    } else if (viewCellSize.z == 0.0f) {
        viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
    }
    vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

    #ifdef USE_3D_VIEW_CELL
        const int faceIndex = int(launchIndex / int(gl_LaunchSizeNV.x / 6.0f));
        
        const vec3 faceRights[6] = { viewCellRight, -viewCellNormal, -viewCellRight, viewCellNormal, viewCellRight, viewCellRight };
        const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCellNormal, viewCellNormal };
        const vec3 faceNormals[6] = { viewCellNormal, viewCellRight, -viewCellNormal, -viewCellRight, viewCellUp, -viewCellUp };
        const vec3 faceSizes[6] = { 
            viewCellSize.xyz,
            viewCellSize.zyx,
            viewCellSize.xyz,
            viewCellSize.zyx,
            viewCellSize.xzy,
            viewCellSize.xzy
        };

        viewCellNormal = faceNormals[faceIndex];
        viewCellRight = faceRights[faceIndex];
        viewCellUp = faceUps[faceIndex];
        viewCellSize = faceSizes[faceIndex];
        viewCellPos = viewCellPos + viewCellNormal * viewCellSize.z * 0.5;
    #endif

    vec3 rayOrigin;
    vec3 rayDir;

    // Map Halton point to point on view cell
    vec2 haltonPoint = vec2(points[launchIndex * 4] - 0.5f, points[launchIndex * 4 + 1] - 0.5f);
    rayOrigin = viewCellPos + haltonPoint.x * viewCellSize.x * viewCellRight + haltonPoint.y * viewCellSize.y * viewCellUp;

    for (int i = 0; i < 1; i++) {
        // Use a different Halton point to calculate the ray direction
        //haltonPoint = vec2(points[launchIndex * 4 + 2], points[launchIndex * 4 + 3]);
        haltonPoint = vec2(points[launchIndex * 4 + 2 + i * 2], points[launchIndex * 4 + 3 + i * 2]);

        // Map Halton point to point on hemisphere
        float phi = 2.0 * 3.1415926 * haltonPoint.x;
        float r = sqrt(max(1.0 - haltonPoint.y * haltonPoint.y, 0.0));
        rayDir = vec3(r * cos(phi), r * sin(phi), haltonPoint.y);

        // Transform direction to view cell coordinate system
        rayDir = normalize(rayDir.x * viewCellRight + rayDir.y * viewCellUp + rayDir.z * viewCellNormal);

        /*
        if (launchIndex == 0) {
            rayDir = normalize(vec3(-25.659540, 17.318491, 11.035990) - rayOrigin);
        } else if (launchIndex == 1) {
            rayOrigin = vec3(-59.571327, 51.222729, 93.720490);
            rayDir = normalize(vec3(-23.551039, 9.746131, 18.934601) - rayOrigin);
        }
        */

        // Trace ray
        uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV | gl_RayFlagsOpaqueNV;
        uint cullMask = 0xff;
        float tmin = 0.001;
        float tmax = 100000.0;
        traceNV(
            topLevelAS,     // acceleration structure
            rayFlags,       // rayFlags
            cullMask,       // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            rayOrigin.xyz,  // ray origin
            tmin,           // ray min range
            rayDir.xyz,     // ray direction
            tmax,           // ray max range
            0               // payload (location = 0)
        );
        
        int triangleID = int(hitInfo.w);
        if (triangleID != -1 && insert(triangleID)) {
            uint index = atomicAdd(triangleCounter, 1);
            randomSamplingOutput[index] = Sample(triangleID, rayOrigin, hitInfo.xyz, hitInfo.xyz);
        }
    }
}

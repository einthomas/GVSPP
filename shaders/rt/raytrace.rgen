#version 460
#extension GL_NV_ray_tracing : require

//#define USE_3D_VIEW_CELL

struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    vec2 points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec3 size;
    vec3 normal;
} viewCell;
layout(binding = 6, set = 0) writeonly buffer randomSamplingOutputBuffer {
    Sample randomSamplingOutput[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

void main() {
    // Calculate 1D launch index
    uint launchIndex = gl_LaunchIDNV.x;

    // Construct view cell coordinate system
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 viewCellRight = normalize(cross(viewCell.normal, up));     // TODO: Doesn't work if the viewcell normal is also (0, 1, 0)!
    vec3 viewCellUp = normalize(cross(viewCellRight, viewCell.normal));
    vec3 viewCellPos = viewCell.pos;
    vec3 viewCellNormal = viewCell.normal;

    #ifdef USE_3D_VIEW_CELL
        const int faceIndex = int(launchIndex / (gl_LaunchSizeNV.x / 6.0f));
        
        const vec3 faceNormals[6] = { viewCell.normal, viewCellRight, -viewCell.normal, -viewCellRight, viewCellUp, -viewCellUp };
        const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCell.normal, viewCell.normal };
        const vec3 faceRights[6] = { viewCellRight, -viewCell.normal, -viewCellRight, viewCell.normal, viewCellRight, viewCellRight };

        viewCellNormal = faceNormals[faceIndex];
        viewCellRight = faceRights[faceIndex];
        viewCellUp = faceUps[faceIndex];
        viewCellPos = viewCell.pos + viewCellNormal * viewCell.size * 0.5;
    #endif

    vec3 rayOrigin;
    vec3 rayDir;

    // Map Halton point to point on view cell
    vec2 haltonPoint = points[launchIndex];
    vec2 offset = (haltonPoint - vec2(0.5)) * viewCell.size.xy;
    rayOrigin = viewCellPos + offset.x * viewCellRight + offset.y * viewCellUp;

    // Use a different Halton point to calculate the ray direction
    haltonPoint = points[int(mod(launchIndex + 1, gl_LaunchSizeNV.x))];

    // Map Halton point to point on hemisphere
    float phi = 2.0 * 3.1415926 * haltonPoint.y;
    float r = sqrt(max(1.0 - haltonPoint.x * haltonPoint.x, 0.0));
    rayDir = vec3(r * cos(phi), r * sin(phi), haltonPoint.x);

    // Transform direction to view cell coordinate system
    rayDir = normalize(rayDir.x * viewCellRight + rayDir.y * viewCellUp + rayDir.z * viewCellNormal);

    // Trace ray
    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    traceNV(
        topLevelAS,     // acceleration structure
        rayFlags,       // rayFlags
        cullMask,       // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        rayOrigin.xyz,  // ray origin
        tmin,           // ray min range
        rayDir.xyz,     // ray direction
        tmax,           // ray max range
        0               // payload (location = 0)
    );

    randomSamplingOutput[launchIndex] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, hitInfo.xyz);
}

#version 460
#extension GL_NV_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 2, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 5, set = 0) readonly buffer haltonPoints {
    vec2 points[];
};
layout(binding = 6, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec2 size;
    vec3 normal;
} viewCell;
layout(binding = 7, set = 0) writeonly buffer trianglesOutputBuffer {       // TODO: Remove, unused
    uint trianglesOutput[];
};

struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
};
layout(binding = 8, set = 0) writeonly buffer rayOriginOutputBuffer {
    Sample rayOriginOutput[];
};

//layout(location = 0) rayPayloadNV uint hitPrimitiveID;
layout(location = 0) rayPayloadNV vec4 hitInfo;

void main() {
    // Calculate 1D launch index
    uint launchIndex = gl_LaunchIDNV.x;

    // Construct view cell coordinate system
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 viewCellRight = normalize(cross(viewCell.normal, up));     // TODO: Doesn't work if the viewcell normal is also (0, 1, 0)!
    vec3 viewCellUp = normalize(cross(viewCellRight, viewCell.normal));
    
    // Map Halton point to point on view cell
    vec2 haltonPoint = points[launchIndex];
    vec2 offset = (haltonPoint - vec2(0.5)) * viewCell.size;
    vec3 rayOrigin = viewCell.pos + offset.x * viewCellRight + offset.y * viewCellUp;

    // Use a different Halton point to calculate the ray direction
    haltonPoint = points[gl_LaunchSizeNV.x - launchIndex - 1];

    // Map Halton point to point on hemisphere
    float phi = 2.0 * 3.1415926 * haltonPoint.y;
    float r = sqrt(max(1.0 - haltonPoint.x * haltonPoint.x, 0.0));
    vec3 rayDir = normalize(vec3(r * cos(phi), r * sin(phi), haltonPoint.x));

    // Transform hemisphere point to view cell coordinate system
    rayDir = rayDir.x * viewCellRight + rayDir.y * viewCellUp + rayDir.z * viewCell.normal;

    //rayOrigin = vec3(0.0, 0.0, 16.0);   // TODO: REMOVE THIS. THIS IS ONLY FOR DEBUGGING PURPOSES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //rayDir = viewCell.normal;      // TODO: REMOVE THIS. THIS IS ONLY FOR DEBUGGING PURPOSES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // Trace ray
    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    traceNV(
        topLevelAS,     // acceleration structure
        rayFlags,       // rayFlags
        cullMask,       // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        rayOrigin.xyz,  // ray origin
        tmin,           // ray min range
        rayDir.xyz,     // ray direction
        tmax,           // ray max range
        0               // payload (location = 0)
    );

    /*
    if (int(hitInfo.w) == 2147483647) {
    rayOriginOutput[launchIndex] = Sample(-2, rayOrigin, hitInfo.xyz);    //Sample(hitPrimitiveID, rayOrigin);
    }else{
        rayOriginOutput[launchIndex] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz);    //Sample(hitPrimitiveID, rayOrigin);
    }
    */

    rayOriginOutput[launchIndex] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz);    //Sample(hitPrimitiveID, rayOrigin);
}

int reverseSampling(uint launchIndex, vec3 rayOrigin, vec3 rayDir, int occludingTriangleID, vec3 samplePos, vec3 hitPoint) {
    int foundSampleIndex = -1;
    if (occludingTriangleID != -1) {
        // Check for discontinuity
        if (length(samplePos - rayOrigin) - length(hitPoint - rayOrigin) > 0.985) {
            // Get view cell coordinate system
            vec3 viewCellSize = vec3(
                length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
                length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
                length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
            ) * 2.0f;
            vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
            vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
            vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
            if (viewCellSize.x == 0.0f) {
                viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
            } else if (viewCellSize.y == 0.0f) {
                viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
            } else if (viewCellSize.z == 0.0f) {
                //viewCellRight = -viewCellRight;
                viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
            }
            vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

            Vertex occludingTriangleVertices[3];
            for (int i = 0; i < 3; i++) {
                occludingTriangleVertices[i] = unpackVertexData(indices.i[3 * occludingTriangleID + i]);
            }
            
            #ifdef USE_3D_VIEW_CELL
                const vec3 faceRights[6] = { viewCellRight, -viewCellNormal, -viewCellRight, viewCellNormal, viewCellRight, viewCellRight };
                const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCellNormal, viewCellNormal };
                const vec3 faceNormals[6] = { viewCellNormal, viewCellRight, -viewCellNormal, -viewCellRight, viewCellUp, -viewCellUp };
                const vec3 faceSizes[6] = { 
                    viewCellSize.xyz,
                    viewCellSize.zyx,
                    viewCellSize.xyz,
                    viewCellSize.zyx,
                    viewCellSize.xzy,
                    viewCellSize.xzy
                };

                for (int m = 0; m < 6; m++) {
                    if (dot(rayDir, faceNormals[m]) < 0) {
                        continue;
                    }

                    viewCellNormal = faceNormals[m];
                    viewCellRight = faceRights[m];
                    viewCellUp = faceUps[m];
                    viewCellSize = faceSizes[m];
                    viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]) + viewCellNormal * viewCellSize.z * 0.5;
            #endif

            bool invalidRayPlaneIntersection = false;
            vec3 rayViewCellHitPoints[3];
            for (int i = 0; i < 3; i++) {
                if (!intersectRayPlane(
                        viewCellPos, viewCellNormal, samplePos, normalize(occludingTriangleVertices[i].worldPos - samplePos),
                        rayViewCellHitPoints[i]
                    )
                ) {
                    invalidRayPlaneIntersection = true;
                    break;
                }
            }

            if (!invalidRayPlaneIntersection) {
                const vec3 v0 = rayViewCellHitPoints[1] - rayViewCellHitPoints[0];
                const vec3 v1 = rayViewCellHitPoints[2] - rayViewCellHitPoints[0];

                const float dot00 = dot(v0, v0);
                const float dot01 = dot(v0, v1);
                const float dot11 = dot(v1, v1);
                const float denom = dot00 * dot11 - dot01 * dot01;
                vec2 corners[4];
                corners[0] = vec2(0.0f);
                corners[1] = vec2(1.0f, 0.0f);
                corners[2] = vec2(0.0f, 1.0f);
                corners[3] = vec2(1.0f);
                int count = 0;
                for (int i = 0; count < 16; i++) {
                    if (i > 100) {
                        break;
                    }

                    // Map Halton point to point on view cell
                    vec2 haltonPoint;
                    if (i < 4) {
                        haltonPoint = corners[i];
                    } else {
                        haltonPoint = vec2(
                            points[int(mod(launchIndex * 4 + 2, points.length()))],
                            points[int(mod(launchIndex * 4 + 3, points.length()))]
                        );
                    }
                    vec2 offset = haltonPoint - vec2(0.5);
                    vec3 viewCellSamplePoint = viewCellPos + offset.x * viewCellSize.x * viewCellRight + offset.y * viewCellSize.y * viewCellUp;

                    // Check if viewCellSamplePoint is within the occluding triangle projected onto the view cell
                    // Ericson, Christer. Real-time collision detection. CRC Press, 2004.
                    const vec3 v2 = viewCellSamplePoint - rayViewCellHitPoints[0];
                    float dot20 = dot(v2, v0);
                    float dot21 = dot(v2, v1);
                    float v = (dot11 * dot20 - dot01 * dot21) / denom;
                    float w = (dot00 * dot21 - dot01 * dot20) / denom;
                    if (any(bvec3(w < 0.0f || w > 1.0f, v < 0.0f || v > 1.0f, w + v > 1.0f))) {
                        vec3 rayOrigin = viewCellSamplePoint;
                        rayDir = normalize(samplePos - viewCellSamplePoint);

                        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                        count++;
                        tracedRsRays++;

    	                int triangleID = int(hitInfo.w);
                        if (triangleID != -1) { // && isTriangleFrontFacing(viewCellNormal, viewCellPos, triangleID)) {
                            vec3 faceNormal = (
                                unpackVertexData(indices.i[3 * triangleID]).normal
                                + unpackVertexData(indices.i[3 * triangleID + 1]).normal
                                + unpackVertexData(indices.i[3 * triangleID + 2]).normal
                            ) / 3.0f;
                            faceNormal = cross(
                                unpackVertexData(indices.i[3 * triangleID + 1]).worldPos - unpackVertexData(indices.i[3 * triangleID]).worldPos,
                                unpackVertexData(indices.i[3 * triangleID + 2]).worldPos - unpackVertexData(indices.i[3 * triangleID]).worldPos
                            );    
                            if (dot(rayDir, faceNormal) < 0.0f) {
                                uint index = storeReverseSample(
                                    launchIndex,
                                    Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos),
                                    samplePos
                                );
                                if (length(hitInfo.xyz - samplePos) < 0.01) {
                                    foundSampleIndex = int(index);
                                }
                            }
                        }
                    } else {
                        // If viewCellSamplePoint is within the projected triangle, three new samples are generated
                        // that lie just outside the three edges of the projected triangle
                        float u = 1.0f - v - w;

                        const float offset = 0.01f;
                        vec3 c[3];
                        float f = (1.0f + offset) / (v + w);
                        c[0] = rayViewCellHitPoints[0] * -offset + rayViewCellHitPoints[1] * (v * f) + rayViewCellHitPoints[2] * (w * f);
                        f = (1.0f + offset) / (u + w);
                        c[1] = rayViewCellHitPoints[0] * (u * f) + rayViewCellHitPoints[1] * -offset + rayViewCellHitPoints[2] * (w * f);
                        f = (1.0f + offset) / (u + v);
                        c[2] = rayViewCellHitPoints[0] * (u * f) + rayViewCellHitPoints[1] * (v * f) + rayViewCellHitPoints[2] * -offset;

                        // Compute corners of the current view face
                        vec3 s0 = viewCellPos - viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;
                        vec3 s1 = viewCellPos + viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;
                        vec3 s2 = viewCellPos - viewCellRight * viewCellSize.x * 0.5 - viewCellUp * viewCellSize.y * 0.5;

                        for (int i = 0; i < 3; i++) {
                            // Check if the ray-plane hit point lies within the bounds of the view cell
                            // Project ray-plane hit point on local basis of the view cell
                            float uu = dot(c[i] - s0, s1 - s0);
                            float vv = dot(c[i] - s0, s2 - s0);

                            // Check if the u & v coordinates are within the view cell
                            if (uu >= 0.0 && vv >= 0.0 && uu <= dot(s1 - s0, s1 - s0) && vv <= dot(s2 - s0, s2 - s0)) {
                                vec3 rayOrigin = c[i];
                                rayDir = normalize(samplePos - c[i]);

                                traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                                count++;
                                tracedRsRays++;

                                int triangleID = int(hitInfo.w);
                                if (triangleID != -1) { // && isTriangleFrontFacing(viewCellNormal, viewCellPos, triangleID)) {
                                    vec3 faceNormal = vec3(
                                        unpackVertexData(indices.i[3 * triangleID]).normal
                                        + unpackVertexData(indices.i[3 * triangleID + 1]).normal
                                        + unpackVertexData(indices.i[3 * triangleID + 2]).normal
                                    ) / 3.0f;
                                    faceNormal = cross(
                                        unpackVertexData(indices.i[3 * triangleID + 1]).worldPos - unpackVertexData(indices.i[3 * triangleID]).worldPos,
                                        unpackVertexData(indices.i[3 * triangleID + 2]).worldPos - unpackVertexData(indices.i[3 * triangleID]).worldPos
                                    );    
                                    if (dot(rayDir, faceNormal) < 0.0f) {
                                        uint index = storeReverseSample(
                                            launchIndex,
                                            Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos),
                                            samplePos
                                        );
                                        if (length(hitInfo.xyz - samplePos) < 0.01) {
                                            foundSampleIndex = int(index);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #ifdef USE_3D_VIEW_CELL
                    if (!invalidRayPlaneIntersection) {
                        //break;
                    }
                }
            #endif
        }
    }

    return foundSampleIndex;
}

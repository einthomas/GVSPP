int reverseSampling(uint launchIndex, vec3 rayOrigin, vec3 rayDir, int occludingTriangleID, vec3 samplePos, vec3 hitPoint) {
    int foundSampleIndex = -1;
    if (occludingTriangleID != -1) {
        // Check for discontinuity
        if (length(samplePos - rayOrigin) - length(hitPoint - rayOrigin) > 0.985) {
            #ifdef USE_3D_VIEW_CELL
                vec3 up = vec3(0.0, 1.0, 0.0);
                vec3 viewCellRight = normalize(cross(viewCell.normal, up));     // TODO: Doesn't work if the viewcell normal is also (0, 1, 0)!
                vec3 viewCellUp = normalize(cross(viewCellRight, viewCell.normal));
                const vec3 faceNormals[6] = { viewCell.normal, viewCellRight, -viewCell.normal, -viewCellRight, viewCellUp, -viewCellUp };
                const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCell.normal, viewCell.normal };
                const vec3 faceRights[6] = { viewCellRight, -viewCell.normal, -viewCellRight, viewCell.normal, viewCellRight, viewCellRight };
            #endif

            Vertex occludingTriangleVertices[3];
            for (int i = 0; i < 3; i++) {
                occludingTriangleVertices[i] = unpackVertexData(indices.i[3 * occludingTriangleID + i]);
            }
            
            #ifdef USE_3D_VIEW_CELL
                for (int m = 0; m < 6; m++) {
                    if (dot(rayDir, faceNormals[m]) > 0) {
                        continue;
                    }

                    vec3 viewCellNormal = faceNormals[m];
                    vec3 viewCellRight = faceRights[m];
                    vec3 viewCellUp = faceUps[m];
                    vec3 viewCellPos = viewCell.pos + viewCellNormal * viewCell.size * 0.5;
                    vec3 viewCellSize = viewCell.size;
            #else
                vec3 up = vec3(0.0, 1.0, 0.0);
                vec3 viewCellRight = normalize(cross(viewCell.normal, up));     // TODO: Doesn't work if the viewcell normal is also (0, 1, 0)!
                vec3 viewCellUp = normalize(cross(viewCellRight, viewCell.normal));
                vec3 viewCellPos = viewCell.tilePos;
                vec3 viewCellNormal = viewCell.normal;
                vec3 viewCellSize = viewCell.size;
            #endif

            bool invalidRayPlayIntersection = false;
            vec3 rayViewCellHitPoints[3];
            for (int i = 0; i < 3; i++) {
                if (!intersectRayPlane(
                        viewCellPos, viewCellNormal, samplePos, normalize(occludingTriangleVertices[i].worldPos - samplePos),
                        rayViewCellHitPoints[i]
                    )
                ) {
                    invalidRayPlayIntersection = true;
                    break;
                }
            }

            if (!invalidRayPlayIntersection) {
                const vec3 v0 = rayViewCellHitPoints[1] - rayViewCellHitPoints[0];
                const vec3 v1 = rayViewCellHitPoints[2] - rayViewCellHitPoints[0];

                const float dot00 = dot(v0, v0);
                const float dot01 = dot(v0, v1);
                const float dot11 = dot(v1, v1);
                const float denom = dot00 * dot11 - dot01 * dot01;
                vec2 corners[4];
                corners[0] = vec2(0.0f);
                corners[1] = vec2(1.0f, 0.0f);
                corners[2] = vec2(0.0f, 1.0f);
                corners[3] = vec2(1.0f);
                int count = 0;
                for (int i = 0; count < 16; i++) {
                    if (i > 100) {
                        break;
                    }

                    // Map Halton point to point on view cell
                    vec2 haltonPoint;
                    if (i < 4) {
                        haltonPoint = corners[i];
                    } else {
                        haltonPoint = vec2(points[(i - 4) * 4 + 2], points[(i - 4) * 4 + 3]);
                    }
                    vec2 offset = haltonPoint - vec2(0.5);
                    vec3 viewCellSamplePoint = viewCellPos + offset.x * viewCellSize * viewCellRight + offset.y * viewCellSize * viewCellUp;

                    // Check if viewCellSamplePoint is within the occluding triangle projected onto the view cell
                    // Ericson, Christer. Real-time collision detection. CRC Press, 2004.
                    const vec3 v2 = viewCellSamplePoint - rayViewCellHitPoints[0];
                    float dot20 = dot(v2, v0);
                    float dot21 = dot(v2, v1);
                    float v = (dot11 * dot20 - dot01 * dot21) / denom;
                    float w = (dot00 * dot21 - dot01 * dot20) / denom;
                    if (any(bvec3(w < 0.0f || w > 1.0f, v < 0.0f || v > 1.0f, w + v > 1.0f))) {
                        rayOrigin = viewCellSamplePoint;
                        rayDir = normalize(samplePos - viewCellSamplePoint);

                        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                        count++;
                        tracedRsRays++;

                        if (int(hitInfo.w) != -1) {
                            uint index = storeReverseSample(
                                launchIndex,
                                Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos),
                                samplePos
                            );
                            if (length(hitInfo.xyz - samplePos) < 0.01) {
                                foundSampleIndex = int(index);
                            }
                        }
                    } else {
                        // If viewCellSamplePoint is within the projected triangle, three new samples are generated
                        // that lie just outside the three edges of the projected triangle
                        float u = 1.0f - v - w;

                        const float offset = 0.01f;
                        vec3 c[3];
                        float f = (1.0f + offset) / (v + w);
                        c[0] = rayViewCellHitPoints[0] * -offset + rayViewCellHitPoints[1] * (v * f) + rayViewCellHitPoints[2] * (w * f);
                        f = (1.0f + offset) / (u + w);
                        c[1] = rayViewCellHitPoints[0] * (u * f) + rayViewCellHitPoints[1] * -offset + rayViewCellHitPoints[2] * (w * f);
                        f = (1.0f + offset) / (u + v);
                        c[2] = rayViewCellHitPoints[0] * (u * f) + rayViewCellHitPoints[1] * (v * f) + rayViewCellHitPoints[2] * -offset;

                        // Compute corners of the current view face
                        vec3 s0 = viewCellPos - viewCellRight * viewCellSize * 0.5 + viewCellUp * viewCellSize * 0.5;
                        vec3 s1 = viewCellPos + viewCellRight * viewCellSize * 0.5 + viewCellUp * viewCellSize * 0.5;
                        vec3 s2 = viewCellPos - viewCellRight * viewCellSize * 0.5 - viewCellUp * viewCellSize * 0.5;

                        for (int i = 0; i < 3; i++) {
                            // Check if the ray-plane hit point lies within the bounds of the view cell
                            // Project ray-plane hit point on local basis of the view cell
                            float uu = dot(c[i] - s0, s1 - s0);
                            float vv = dot(c[i] - s0, s2 - s0);

                            // Check if the u & v coordinates are within the view cell
                            if (uu >= 0.0 && vv >= 0.0 && uu <= dot(s1 - s0, s1 - s0) && vv <= dot(s2 - s0, s2 - s0)) {
                                rayOrigin = c[i];
                                rayDir = normalize(samplePos - c[i]);

                                traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                                count++;
                                tracedRsRays++;

                                if (int(hitInfo.w) != -1) {
                                    uint index = storeReverseSample(
                                        launchIndex,
                                        Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos),
                                        samplePos
                                    );
                                    if (length(hitInfo.xyz - samplePos) < 0.01) {
                                        foundSampleIndex = int(index);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #ifdef USE_3D_VIEW_CELL
                }
            #endif
        }
    }

    return foundSampleIndex;
}

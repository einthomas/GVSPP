const int NUM_SAMPLES_ALONG_EDGE = 5;   // Number includes corner samples

bool reverseSampling(uint launchIndex, vec3 rayOrigin, vec3 rayDir, int occludingTriangleID, const vec3 samplePos, vec3 hitPoint, out Sample foundSample) {
    bool discontinuityFound = false;
    if (occludingTriangleID != -1) {
        // Check for discontinuity
        const float samplePointDistance = length(samplePos - rayOrigin);
        if (samplePointDistance - length(hitPoint - rayOrigin) > 0.985) {
            foundSample.triangleID = -2;
            discontinuityFound = true;

            // Get view cell coordinate system
            vec3 viewCellSize = vec3(
                length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
                length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
                length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
            ) * 2.0f;
            vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
            vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
            vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
            if (viewCellSize.x == 0.0f) {
                viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
            } else if (viewCellSize.y == 0.0f) {
                viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
            } else if (viewCellSize.z == 0.0f) {
                //viewCellRight = -viewCellRight;
                viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
            }
            vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

            Vertex occludingTriangleVertices[3];
            for (int i = 0; i < 3; i++) {
                occludingTriangleVertices[i] = unpackVertexData(indices.i[3 * occludingTriangleID + i]);
            }
            
            #ifdef USE_3D_VIEW_CELL
                const vec3 faceRights[6] = { viewCellRight, -viewCellNormal, -viewCellRight, viewCellNormal, viewCellRight, viewCellRight };
                const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCellNormal, viewCellNormal };
                const vec3 faceNormals[6] = { viewCellNormal, viewCellRight, -viewCellNormal, -viewCellRight, viewCellUp, -viewCellUp };
                const vec3 faceSizes[6] = { 
                    viewCellSize.xyz,
                    viewCellSize.zyx,
                    viewCellSize.xyz,
                    viewCellSize.zyx,
                    viewCellSize.xzy,
                    viewCellSize.xzy
                };

                vec3 startRayDir = rayDir;
                for (int m = 0; m < 6; m++) {
                    if (dot(startRayDir, faceNormals[m]) < 0) {
                        continue;
                    }

                    viewCellNormal = faceNormals[m];
                    viewCellRight = faceRights[m];
                    viewCellUp = faceUps[m];
                    viewCellSize = faceSizes[m];
                    viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]) + viewCellNormal * viewCellSize.z * 0.5;
            #endif

            bool invalidRayPlaneIntersection = false;
            vec3 rayViewCellHitPoints[3];
            for (int i = 0; i < 3; i++) {
                // Intersect a ray originating at samplePos through the vertices of the occluding triangle with the view cell i.e.
                // the occluding triangle is projected onto the view cell
                if (!intersectRayPlane(
                        viewCellPos, viewCellNormal, samplePos, normalize(occludingTriangleVertices[i].worldPos - samplePos),
                        rayViewCellHitPoints[i]
                    )
                ) {
                    invalidRayPlaneIntersection = true;
                    break;
                }
            }

            if (!invalidRayPlaneIntersection) {
                const vec3 v0 = rayViewCellHitPoints[1] - rayViewCellHitPoints[0];
                const vec3 v1 = rayViewCellHitPoints[2] - rayViewCellHitPoints[0];

                const float dot00 = dot(v0, v0);
                const float dot01 = dot(v0, v1);
                const float dot11 = dot(v1, v1);
                const float denom = dot00 * dot11 - dot01 * dot01;

                // Get the corners of the view cell
                vec3 corners[4];
                corners[0] = viewCellPos - viewCellRight * viewCellSize.x * 0.5 - viewCellUp * viewCellSize.y * 0.5;    // bottom left
                corners[1] = viewCellPos - viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;    // top left
                corners[2] = viewCellPos + viewCellRight * viewCellSize.x * 0.5 + viewCellUp * viewCellSize.y * 0.5;    // top right
                corners[3] = viewCellPos + viewCellRight * viewCellSize.x * 0.5 - viewCellUp * viewCellSize.y * 0.5;    // bottom right

                // Mutate the ray origin along the edges of the view cell. If the mutated ray origin lies outside the
                // projected triangle, a ray is traced using the mutated ray origin
                for (int i = 0; i < 4; i++) {
                    vec3 vec = (corners[(i + 1) % 4] - corners[i]) / float(NUM_SAMPLES_ALONG_EDGE - 1);
                    for (int k = 0; k < NUM_SAMPLES_ALONG_EDGE - 1; k++) {
                        const vec3 viewCellSamplePoint = corners[i] + vec * k;

                        // Check if viewCellSamplePoint is within the occluding triangle projected onto the view cell
                        // Ericson, Christer. Real-time collision detection. CRC Press, 2004.
                        const vec3 v2 = viewCellSamplePoint - rayViewCellHitPoints[0];
                        const float dot20 = dot(v2, v0);
                        const float dot21 = dot(v2, v1);
                        const float v = (dot11 * dot20 - dot01 * dot21) / denom;
                        const float w = (dot00 * dot21 - dot01 * dot20) / denom;
                        if (any(bvec3(w < 0.0f || w > 1.0f, v < 0.0f || v > 1.0f, w + v > 1.0f))) {
                            const vec3 rayOrigin = viewCellSamplePoint;
                            traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, normalize(samplePos - viewCellSamplePoint), 100000.0, 0);
                            tracedRsRays++;

                            int triangleID = int(hitInfo.w);
                            #ifdef USE_3D_VIEW_CELL
                                vec3 faceNormal = vec3(
                                    unpackVertexData(indices.i[3 * triangleID]).normal
                                    + unpackVertexData(indices.i[3 * triangleID + 1]).normal
                                    + unpackVertexData(indices.i[3 * triangleID + 2]).normal
                                ) / 3.0f;
                                if (dot(normalize(samplePos - viewCellSamplePoint), faceNormal) < 0.0f) {
                            #endif
                                if (triangleID != -1) { // && isTriangleFrontFacing(viewCellNormal, viewCellPos, triangleID)) {
                                    bool targetSampleReached = (length(hitInfo.xyz - rayOrigin) - samplePointDistance > 0.0f) && (foundSample.triangleID == -2);
                                    if (targetSampleReached) {
                                        foundSample = Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos);
                                    }
                                    int index = storeReverseSample(
                                        launchIndex,
                                        Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos),
                                        targetSampleReached
                                    );
                                    
                                    if (index != -1) {
                                    //if (length(hitInfo.xyz - rayOrigin) - samplePointDistance > 0.0f) {
                                        //foundSampleIndex = index;
                                    }
                                }
                            #ifdef USE_3D_VIEW_CELL
                            }
                            #endif
                        }
                    }
                }
            }
            #ifdef USE_3D_VIEW_CELL
                    if (!invalidRayPlaneIntersection) {
                        //break;
                    }
                }
            #endif
        }
    }

    return discontinuityFound;
}

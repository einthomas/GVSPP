#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 2, set = 0) buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 3, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    mat4 model;
} viewCell;
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
};

layout(binding = 0, set = 1) readonly buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 1, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(binding = 0, set = 2) buffer edgeSubdivOutputBuffer {
    Sample edgeSubdivOutput[];
};
layout(binding = 1, set = 2) writeonly buffer edgeSubdivIDOutputBuffer {
    int triangleIDOutput[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

#include "util.glsl"

const float SAMPLE_DISTANCE_THRESHOLD = 0.001;
const int MAX_SUBDIVISION_STEPS = 3;
uint tracedRays = 0;

uint storeReverseSample(uint launchIndex, Sample s, vec3 targetSamplePos) {
    atomicAdd(rsTriangleCounter, 1);
    uint index = atomicAdd(triangleCounter, 1);
    triangleIDOutput[index] = s.triangleID;
    edgeSubdivOutput[index] = s;

    return index;
}

uint tracedRsRays = 0;

#if REVERSE_SAMPLING_METHOD == 0
    #include "reverse_sampling_cpu_impl.rgen"
#elif REVERSE_SAMPLING_METHOD == 1
    #include "reverse_sampling_gvs.rgen"
#elif REVERSE_SAMPLING_METHOD == 2
    #include "reverse_sampling_new.rgen"
#endif

void main() {
    const uint launchIndex = gl_LaunchIDNV.x;
    const uint currentTriangleIndex = uint(floor(launchIndex / 15.0));
    const int numSamplesPerEdge = int(pow(2, MAX_SUBDIVISION_STEPS) + 1);

    #if REVERSE_SAMPLING_METHOD == 1
        Sample originalSample = absWorking[currentTriangleIndex];
        Vertex v[3];
        v[0] = unpackVertexData(indices.i[3 * originalSample.triangleID]);
        v[1] = unpackVertexData(indices.i[3 * originalSample.triangleID + 1]);
        v[2] = unpackVertexData(indices.i[3 * originalSample.triangleID + 2]);
    #endif

    // Get view cell coordinate system
    vec3 viewCellSize = vec3(
        length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
        length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
        length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
    ) * 2.0f;
    vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
    vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
    vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
    if (viewCellSize.x == 0.0f) {
        viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
    } else if (viewCellSize.y == 0.0f) {
        viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
    } else if (viewCellSize.z == 0.0f) {
        //viewCellRight = -viewCellRight;
        viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
    }
    vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

    // Get two adjacent samples
    uint i = launchIndex;
    Sample s0 = absOutput[i];
    i = (int(mod(launchIndex + 1, 15) + 15 * currentTriangleIndex));
    Sample s1 = absOutput[i];

    // Only subdivide the edge between two adjacent samples if they correspond to
    // different triangles
    if (s0.triangleID != s1.triangleID) {
        int index = int(numSamplesPerEdge / 2.0f);

        // Initialize the array storing the generated samples
        Sample samplesOutput[numSamplesPerEdge];
        for (int k = 0; k < numSamplesPerEdge; k++) {
            samplesOutput[k] = Sample(-2, vec3(0.0), vec3(0.0), vec3(0.0));
        }

        samplesOutput[0] = s0;
        samplesOutput[numSamplesPerEdge - 1] = s1;

        vec3 rayOrigin;
        if (s0.triangleID != -1) {
            rayOrigin = s0.rayOrigin;
        } else {
            rayOrigin = s1.rayOrigin;
        }

        // Calculate the first sample in the middle of the edge
        vec3 samplePos = (samplesOutput[numSamplesPerEdge - 1].pos + samplesOutput[0].pos) / 2.0f;
        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, normalize(samplePos - rayOrigin), 100000.0, 0);
        tracedRays++;
        samplesOutput[index] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);

        vec3 offset = (samplesOutput[numSamplesPerEdge - 1].pos - samplesOutput[0].pos) / 2.0f;
        for (int k = 0; k < MAX_SUBDIVISION_STEPS - 1; k++) {
            offset /= 2.0f;

            // Continue subdivision only if the distance of the new samples are
            // further than a threshold
            if (length(offset) <= SAMPLE_DISTANCE_THRESHOLD) {
                continue;
            }

            for (int m = 0; m < pow(2, k); m++) {
                int currentIndex = index + (index * 2) * m;
                Sample currentSample = samplesOutput[currentIndex];
                if (currentSample.triangleID == -2) {
                    continue;
                }

                // Check if a new sample should be generated and a ray traced, that is if two adjacent
                // samples correspond to different triangles
                if (currentSample.triangleID != samplesOutput[int(currentIndex + index)].triangleID) {
                    vec3 rayOrigin;
                    if (currentSample.triangleID != -1) {
                        rayOrigin = currentSample.rayOrigin;
                    } else {
                        rayOrigin = samplesOutput[int(currentIndex + index)].rayOrigin;
                    }

                    // Calculate the position of a new sample in direction +offset of the current sample
                    vec3 samplePos = currentSample.pos + offset;
                    vec3 rayDir = normalize(samplePos - rayOrigin);
                    #ifndef USE_3D_VIEW_CELL
                        if (dot(rayDir, viewCellNormal) > 0) {
                    #endif
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                    tracedRays++;

                    Sample newSample = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);
                    if (newSample.triangleID != -1) {
                        vec3 faceNormal = vec3(
                            unpackVertexData(indices.i[3 * newSample.triangleID]).normal
                            + unpackVertexData(indices.i[3 * newSample.triangleID + 1]).normal
                            + unpackVertexData(indices.i[3 * newSample.triangleID + 2]).normal
                        ) / 3.0f;
                        if (dot(rayDir, faceNormal) < 0.0f) {
                            
                            if (newSample.triangleID != -1) {
                                #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                                    int foundReverseSampleIndex = reverseSampling(launchIndex, rayOrigin, rayDir, newSample.triangleID, samplePos, newSample.rayHitPos);
                                #elif REVERSE_SAMPLING_METHOD == 1
                                    int foundReverseSampleIndex = reverseSampling(launchIndex, v, originalSample, rayOrigin, rayDir, newSample.triangleID, samplePos, newSample.rayHitPos);
                                #endif
                                if (foundReverseSampleIndex != -1) {
                                    Sample temp = newSample;
                                    newSample = edgeSubdivOutput[foundReverseSampleIndex];
                                    triangleIDOutput[foundReverseSampleIndex] = temp.triangleID;
                                    edgeSubdivOutput[foundReverseSampleIndex] = temp;
                                }
                            }
                            
                            samplesOutput[int(currentIndex + index / 2.0f)] = newSample;
                        }
                    }
                    #ifndef USE_3D_VIEW_CELL
                        }
                    #endif
                }

                if (currentSample.triangleID != samplesOutput[int(currentIndex - index)].triangleID) {
                    vec3 rayOrigin;
                    if (currentSample.triangleID != -1) {
                        rayOrigin = currentSample.rayOrigin;
                    } else {
                        rayOrigin = samplesOutput[int(currentIndex - index)].rayOrigin;
                    }

                    // Calculate the position of a new sample in direction -offset of the current sample
                    vec3 samplePos = currentSample.pos - offset;
                    vec3 rayDir = normalize(samplePos - rayOrigin);
                    #ifndef USE_3D_VIEW_CELL
                        if (dot(rayDir, viewCellNormal) > 0) {
                    #endif
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                    tracedRays++;

                    Sample newSample = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);
                    if (newSample.triangleID != -1) {
                        vec3 faceNormal = vec3(
                            unpackVertexData(indices.i[3 * newSample.triangleID]).normal
                            + unpackVertexData(indices.i[3 * newSample.triangleID + 1]).normal
                            + unpackVertexData(indices.i[3 * newSample.triangleID + 2]).normal
                        ) / 3.0f;
                        if (dot(rayDir, faceNormal) < 0.0f) {
                            
                            if (newSample.triangleID != -1) {
                                #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                                    int foundReverseSampleIndex = reverseSampling(launchIndex, rayOrigin, rayDir, newSample.triangleID, samplePos, newSample.rayHitPos);
                                #elif REVERSE_SAMPLING_METHOD == 1
                                    int foundReverseSampleIndex = reverseSampling(launchIndex, v, originalSample, rayOrigin, rayDir, newSample.triangleID, samplePos, newSample.rayHitPos);
                                #endif
                                if (foundReverseSampleIndex != -1) {
                                    Sample temp = newSample;
                                    newSample = edgeSubdivOutput[foundReverseSampleIndex];
                                    triangleIDOutput[foundReverseSampleIndex] = temp.triangleID;
                                    edgeSubdivOutput[foundReverseSampleIndex] = temp;
                                }
                            }
                            
                            samplesOutput[int(currentIndex - index / 2.0f)] = newSample;
                        }
                    }
                    #ifndef USE_3D_VIEW_CELL
                        }
                    #endif
                }
            }

            index = int(index / 2.0f);
        }

        // Count then umber of triangles that have been found
        const int numSubdivSamples = numSamplesPerEdge - 2;
        uint foundTriangles = 0;
        for (int k = 0; k < numSubdivSamples; k++) {
            #ifdef USE_3D_VIEW_CELL
                if (samplesOutput[k + 1].triangleID >= 0) {
                    foundTriangles++;
                }
            #else
                // In case of a 2d view cell, also check if the found triangle is front-facing
                if (samplesOutput[k + 1].triangleID >= 0 && isTriangleFrontFacing(viewCellNormal, viewCellPos, samplesOutput[k + 1].triangleID)) {
                    foundTriangles++;
                } else {
                    samplesOutput[k + 1].triangleID = -1;
                }
            #endif
        }

        if (foundTriangles > 0) {
            // Add the samples to the output buffer
            uint insertionIndex = atomicAdd(triangleCounter, foundTriangles);
            for (int k = 0, m = 0; k < numSubdivSamples; k++) {
                if (samplesOutput[k + 1].triangleID >= 0) {
                    triangleIDOutput[insertionIndex + m] = samplesOutput[k + 1].triangleID;
                    edgeSubdivOutput[insertionIndex + m] = samplesOutput[k + 1];
                    m++;
                }
            }
        }

        atomicAdd(rayCounter, tracedRays);
        atomicAdd(rsRayCounter, tracedRsRays);
    }
}

#version 460
#extension GL_NV_ray_tracing : require

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;    // TODO: Remove
layout(binding = 2, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 4, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 5, set = 0) readonly buffer haltonPoints {
    vec2 points[];
};
layout(binding = 6, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec2 size;
    vec3 normal;
} viewCell;
layout(binding = 7, set = 0) writeonly buffer foundTrianglesBuffer {       // TODO: Remove, unused
    uint foundTriangles[];
};
layout(binding = 8, set = 0) writeonly buffer rayOriginOutputBuffer {
    Sample rayOriginOutput[];
};

layout(binding = 0, set = 1) writeonly buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 2, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(binding = 0, set = 2) readonly buffer edgeSubdivWorkingBuffer {
    Sample edgeSubdivWorking[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

const float THRESHOLD = 0.01;
const int MAX_SUBDIVISION_STEPS = 3;

void main() {
    uint launchIndex = gl_LaunchIDNV.x;

    Sample s0 = edgeSubdivWorking[launchIndex];
    Sample s1 = edgeSubdivWorking[int(mod(launchIndex + 1, 9.0))];
    const int numSamples = int(pow(2, MAX_SUBDIVISION_STEPS + 1) + 1);
    Sample samples[numSamples];
    if (s0.triangleID != s1.triangleID) {
        samples[0] = s0;
        samples[1] = s1;

        vec3 rayOrigin = s0.rayOrigin;
        vec3 rayDir = (s0.rayHitPos + s1.rayHitPos) * 0.5 - rayOrigin;
        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);

        int triangleID = int(hitInfo.w);
        if (triangleID != s0.triangleID || triangleID != s1.triangleID) {
            samples[2] = Sample(triangleID, rayOrigin, hitInfo.xyz);
        }
        
        int end = 3;
        int numInserted = 1;
        int newNumInserted = 0;
        int i = 0;
        for (int j = 0; j < MAX_SUBDIVISION_STEPS; j++) {
            for (int k = 0; k < 2; k++) {
                for (i = 0; i < numInserted; i++) {
                    s0 = samples[k];
                    s1 = samples[end - numInserted + i];

                    if (s0.triangleID == s1.triangleID) {
                        samples[end + i] = s1;
                    } else {
                        // TODO: Check sample distance for threshold

                        rayOrigin = s0.rayOrigin;
                        rayDir = (s0.rayHitPos + s1.rayHitPos) * 0.5 - rayOrigin;
                        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);

                        triangleID = int(hitInfo.w);
                        if (triangleID != s0.triangleID || triangleID != s1.triangleID) {
                            samples[end + i] = Sample(triangleID, rayOrigin, hitInfo.xyz);
                        } else {
                            // Case where the new sample is on the same triangle as s0 and as s1
                            samples[end + i] = s1;
                        }
                    }
                }
                newNumInserted += i;
                end += i;
            }
            numInserted = newNumInserted;
            newNumInserted = 0;
        }

        for (int i = 0; i < numSamples; i++) {
            absOutput[launchIndex * numSamples + i] = samples[i];
        }
    } else {
        for (int i = 0; i < numSamples; i++) {
            absOutput[launchIndex * numSamples + i] = Sample(-1, vec3(0.0), vec3(0.0));
        }
    }
}

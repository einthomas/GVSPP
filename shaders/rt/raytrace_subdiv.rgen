#version 460
#extension GL_NV_ray_tracing : require

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;    // TODO: Remove
layout(binding = 2, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 4, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 5, set = 0) readonly buffer haltonPoints {
    vec2 points[];
};
layout(binding = 6, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec2 size;
    vec3 normal;
} viewCell;
layout(binding = 7, set = 0) writeonly buffer foundTrianglesBuffer {       // TODO: Remove, unused
    uint foundTriangles[];
};
layout(binding = 8, set = 0) writeonly buffer rayOriginOutputBuffer {
    Sample rayOriginOutput[];
};

layout(binding = 0, set = 1) writeonly buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 2, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(binding = 0, set = 2) readonly buffer edgeSubdivWorkingBuffer {
    Sample edgeSubdivWorking[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

const float THRESHOLD = 0.01;
const int MAX_SUBDIVISION_STEPS = 3;

void main() {
    uint launchIndex = gl_LaunchIDNV.x;
    uint currentTriangleIndex = uint(floor(launchIndex / 9.0));

    Sample s0 = edgeSubdivWorking[launchIndex];
    Sample s1 = edgeSubdivWorking[int(mod(launchIndex + 1, 9.0) + 9 * currentTriangleIndex)];
    //Sample s1 = edgeSubdivWorking[int(mod(launchIndex + 1, 9.0))];
    const int numSamples = int(pow(2, MAX_SUBDIVISION_STEPS) + 1);
    if (s0.triangleID != s1.triangleID) {
        Sample samples[numSamples];
        samples[0] = s0;
        samples[1] = s1;

        vec3 rayOrigin = s0.rayOrigin;
        vec3 samplePos = (s0.pos + s1.pos) * 0.5;
        vec3 rayDir = normalize(samplePos - rayOrigin);
        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);

        int triangleID = int(hitInfo.w);
        if (triangleID != s0.triangleID || triangleID != s1.triangleID) {
            samples[2] = Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos);
        }
        
        int end = 3;
        int numInserted = 1;
        for (int j = 0; j < MAX_SUBDIVISION_STEPS - 1; j++) {
            for (int i = 0; i < numInserted; i++) {
                for (int k = 0; k < 2; k++) {
                    s0 = samples[k];
                    s1 = samples[1 + numInserted + i];

                    if (s0.triangleID == s1.triangleID) {
                        // Both samples are on the same triangle, no new sample has to be generated
                        samples[end] = s1;
                    } else {
                        // TODO: Check sample distance for threshold

                        rayOrigin = s0.rayOrigin;
                        samplePos = (s0.pos + s1.pos) * 0.5;
                        rayDir = normalize(samplePos - rayOrigin);
                        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);

                        triangleID = int(hitInfo.w);
                        if (triangleID != s0.triangleID || triangleID != s1.triangleID) {
                            // The new sample is on a new triangle than at least one of its adjacent samples
                            samples[end] = Sample(triangleID, rayOrigin, hitInfo.xyz, samplePos);
                        } else {
                            // The new sample is on the same triangle as s0 and as s1, no new sample has
                            // to be generated
                            samples[end] = s1;
                        }
                    }
                    end++;
                }
            }
            numInserted *= 2;
        }

        for (int i = 0; i < numSamples; i++) {
            absOutput[launchIndex * numSamples + i] = samples[i];
        }
    } else {
        // Both samples correspond to the same triangle, therefore there can't be another triangle
        // between these two samples
        for (int i = 0; i < numSamples; i++) {
            absOutput[launchIndex * numSamples + i] = Sample(-1, vec3(0.0), vec3(0.0), vec3(0.0));
        }
    }
}

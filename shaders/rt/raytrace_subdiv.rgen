#version 460
#extension GL_NV_ray_tracing : require

struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;

layout(binding = 0, set = 2) buffer edgeSubdivOutputBuffer {
    Sample edgeSubdivOutput[];
};
layout(binding = 1, set = 2) readonly buffer edgeSubdivWorkingBuffer {
    Sample edgeSubdivWorking[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

const float SAMPLE_DISTANCE_THRESHOLD = 0.001;
const int MAX_SUBDIVISION_STEPS = 3;

void main() {
    uint launchIndex = gl_LaunchIDNV.x;
    uint currentTriangleIndex = uint(floor(launchIndex / 9.0));
    const int numSamplesPerEdge = int(pow(2, MAX_SUBDIVISION_STEPS) + 1);

    // Get two adjacent samples
    Sample s0 = edgeSubdivWorking[launchIndex];
    Sample s1 = edgeSubdivWorking[int(mod(launchIndex + 1, 9.0) + 9 * currentTriangleIndex)];

    // Only subdivide the edge between two adjacent samples if they correspond to
    // different triangles
    if (s0.triangleID != s1.triangleID) {
        int index = int(numSamplesPerEdge / 2.0f);

        // Initialize the array storing the generated samples
        for (int i = 0; i < numSamplesPerEdge; i++) {
            edgeSubdivOutput[launchIndex * numSamplesPerEdge + i] = Sample(-2, vec3(0.0), vec3(0.0), vec3(0.0));
        }

        edgeSubdivOutput[launchIndex * numSamplesPerEdge] = s0;
        edgeSubdivOutput[launchIndex * numSamplesPerEdge + numSamplesPerEdge - 1] = s1;

        vec3 rayOrigin;
        if (s0.triangleID != -1) {
            rayOrigin = s0.rayOrigin;
        } else {
            rayOrigin = s1.rayOrigin;
        }

        // Calculate the first sample in the middle of the edge
        vec3 samplePos = (s1.pos + s0.pos) / 2.0f;
        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, normalize(samplePos - rayOrigin), 100000.0, 0);
        edgeSubdivOutput[launchIndex * numSamplesPerEdge + index] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);

        vec3 offset = (edgeSubdivOutput[launchIndex * numSamplesPerEdge + numSamplesPerEdge - 1].pos - edgeSubdivOutput[launchIndex * numSamplesPerEdge + 0].pos) / 2.0f;
        for (int i = 0; i < MAX_SUBDIVISION_STEPS - 1; i++) {
            offset /= 2.0f;

            // Continue subdivision only if the distance of the new samples are
            // further than a threshold
            if (length(offset) <= SAMPLE_DISTANCE_THRESHOLD) {
                continue;
            }

            for (int k = 0; k < pow(2, i); k++) {
                int currentIndex = index + (index * 2) * k;
                Sample currentSample = edgeSubdivOutput[launchIndex * numSamplesPerEdge + currentIndex];
                if (currentSample.triangleID == -2) {
                    continue;
                }

                // Check if a new sample should be generated and a ray traced, that is if two adjacent
                // samples correspond to different triangles
                if (currentSample.triangleID != edgeSubdivOutput[launchIndex * numSamplesPerEdge + int(currentIndex + index)].triangleID) {
                    vec3 rayOrigin;
                    if (currentSample.triangleID != -1) {
                        rayOrigin = currentSample.rayOrigin;
                    } else {
                        rayOrigin = edgeSubdivOutput[launchIndex * numSamplesPerEdge + int(currentIndex + index)].rayOrigin;
                    }

                    // Calculate the position of a new sample in direction +offset of the current sample
                    vec3 samplePos = currentSample.pos + offset;
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, normalize(samplePos - rayOrigin), 100000.0, 0);
                    edgeSubdivOutput[launchIndex * numSamplesPerEdge + int(currentIndex + index / 2.0f)] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);
                }

                if (currentSample.triangleID != edgeSubdivOutput[launchIndex * numSamplesPerEdge + int(currentIndex - index)].triangleID) {
                    vec3 rayOrigin;
                    if (currentSample.triangleID != -1) {
                        rayOrigin = currentSample.rayOrigin;
                    } else {
                        rayOrigin = edgeSubdivOutput[launchIndex * numSamplesPerEdge + int(currentIndex - index)].rayOrigin;
                    }

                    // Calculate the position of a new sample in direction -offset of the current sample
                    vec3 samplePos = currentSample.pos - offset;
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, normalize(samplePos - rayOrigin), 100000.0, 0);
                    edgeSubdivOutput[launchIndex * numSamplesPerEdge + int(currentIndex - index / 2.0f)] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);
                }
            }

            index = int(index / 2.0f);
        }
    } else {
        for (int i = 0; i < numSamplesPerEdge; i++) {
            edgeSubdivOutput[launchIndex * numSamplesPerEdge + i] = Sample(-1, vec3(0.0), vec3(0.0), vec3(0.0));
        }
    }
}

#version 460
#extension GL_NV_ray_tracing : require

#define USE_3D_VIEW_CELL

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 2, set = 0) buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 3, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec3 size;
    vec3 normal;
    vec3 tilePos;
    vec3 tileSize;
} viewCell;
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
};

layout(binding = 0, set = 1) readonly buffer absOutputBuffer {
    Sample absOutput[];
};

layout(binding = 0, set = 2) writeonly buffer edgeSubdivOutputBuffer {
    Sample edgeSubdivOutput[];
};
layout(binding = 1, set = 2) writeonly buffer edgeSubdivIDOutputBuffer {
    int triangleIDOutput[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

const float SAMPLE_DISTANCE_THRESHOLD = 0.001;
const int MAX_SUBDIVISION_STEPS = 3;
uint tracedRays = 0;

Vertex unpackVertexData(uint index) {
    vec4 d0 = vertices.v[3 * index + 0];
    vec4 d1 = vertices.v[3 * index + 1];
    vec4 d2 = vertices.v[3 * index + 2];

    Vertex vertex;
    vertex.pos = d0.xyz;
    vertex.worldPos = vec3(camera.model * vec4(vertex.pos, 1.0));
    vertex.normal = vec3(d0.w, d1.xy);
    vertex.color = vec3(d1.zw, d2.x);
    vertex.uv = d2.yz;

    return vertex;
}

bool isTriangleFrontFacing(vec3 viewCellNormal, vec3 viewCellPos,  int triangleID) {
    Vertex v0 = unpackVertexData(indices.i[3 * triangleID]);
    Vertex v1 = unpackVertexData(indices.i[3 * triangleID + 1]);
    Vertex v2 = unpackVertexData(indices.i[3 * triangleID + 2]);
    return (dot(viewCellNormal, v0.worldPos - viewCellPos) > 0
        || dot(viewCellNormal, v1.worldPos - viewCellPos) > 0
        || dot(viewCellNormal, v2.worldPos - viewCellPos) > 0);
}

bool intersectRayPlane(vec3 d, vec3 normal, vec3 rayOrigin, vec3 rayDir, out vec3 hitPoint) {
    float denom = dot(rayDir, normal);
    if (abs(denom) > 1e-6) {
        float t = dot(d - rayOrigin, normal) / denom;
        hitPoint = rayOrigin + t * rayDir;

        return true;
    }

    return false;
}

bool checkDiscontinuity(vec3 rayOrigin, vec3 rayDir, Sample s, out vec3 mutatedRayOrigin) {
    bool found = false;

    // Check for discontinuity
    Sample reverseSamplingSample = Sample(-1, vec3(0.0), vec3(0.0), vec3(0.0));
    if (length(s.pos - rayOrigin) - length(s.rayHitPos - rayOrigin) > 0.985) {
        Vertex occludingTriangleVertices[3];
        for (int i = 0; i < 3; i++) {
            occludingTriangleVertices[i] = unpackVertexData(indices.i[3 * s.triangleID + i]);
        }

        bool invalidRayPlayIntersection = false;
        vec3 rayViewCellHitPoints[3];
        for (int i = 0; i < 3; i++) {
            if (!intersectRayPlane(
                    viewCell.pos, viewCell.normal, s.pos, normalize(occludingTriangleVertices[i].worldPos - s.pos),
                    rayViewCellHitPoints[i]
                )
            ) {
                invalidRayPlayIntersection = true;
                break;
            }
        }

        if (!invalidRayPlayIntersection) {
            // Construct view cell coordinate system
            vec3 up = vec3(0.0, 1.0, 0.0);
            vec3 viewCellRight = normalize(cross(viewCell.normal, up));     // TODO: Doesn't work if the viewcell normal is also (0, 1, 0)!
            vec3 viewCellUp = normalize(cross(viewCellRight, viewCell.normal));
            vec3 viewCellPos = viewCell.tilePos;
            vec3 viewCellNormal = viewCell.normal;
            vec3 viewCellSize = viewCell.tileSize;
            #ifdef USE_3D_VIEW_CELL
                int index = int(launchIndex / int(gl_LaunchSizeNV.x / float(pushConstants.faceIndices[0])));
                index = index > pushConstants.faceIndices[0] - 1 ? index - 1 : index;
                index += 1;
                const int faceIndex = pushConstants.faceIndices[index];
                
                const vec3 faceNormals[6] = { viewCell.normal, viewCellRight, -viewCell.normal, -viewCellRight, viewCellUp, -viewCellUp };
                const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCell.normal, viewCell.normal };
                const vec3 faceRights[6] = { viewCellRight, -viewCell.normal, -viewCellRight, viewCell.normal, viewCellRight, viewCellRight };

                viewCellNormal = faceNormals[faceIndex];
                viewCellRight = faceRights[faceIndex];
                viewCellUp = faceUps[faceIndex];
                viewCellPos = viewCell.pos + viewCellNormal * viewCell.size * 0.5;
                viewCellSize = size;
            #endif

            const vec3 v0 = rayViewCellHitPoints[1] - rayViewCellHitPoints[0];
            const vec3 v1 = rayViewCellHitPoints[2] - rayViewCellHitPoints[0];

            //const vec3 v0 = occludingTriangleVertices[1].worldPos - occludingTriangleVertices[0].worldPos;
            //const vec3 v1 = occludingTriangleVertices[2].worldPos - occludingTriangleVertices[0].worldPos;
            const float dot00 = dot(v0, v0);
            const float dot01 = dot(v0, v1);
            const float dot11 = dot(v1, v1);
            const float denom = dot00 * dot11 - dot01 * dot01;
            vec2 corners[4];
            corners[0] = vec2(0.0f);
            corners[1] = vec2(1.0f, 0.0f);
            corners[2] = vec2(0.0f, 1.0f);
            corners[3] = vec2(1.0f);
            int count = 0;
            for (int i = 0; count < 4; i++) {
                if (i > 16) {
                    break;
                }

                // Map Halton point to point on view cell
                vec2 haltonPoint;
                if (i < 4) {
                    haltonPoint = corners[i];
                } else {
                    haltonPoint = vec2(points[(i - 4) * 4 + 2], points[(i - 4) * 4 + 3]);
                }
                vec2 offset = (haltonPoint - vec2(0.5)) * viewCellSize.xy;
                vec3 viewCellSamplePoint = viewCellPos + offset.x * viewCellRight + offset.y * viewCellUp;

                bool pointFound = false;

                // Check if sample point is within projected triangle
                // Ericson, Christer. Real-time collision detection. CRC Press, 2004.
                const vec3 v2 = viewCellSamplePoint - rayViewCellHitPoints[0];
                float dot20 = dot(v2, v0);
                float dot21 = dot(v2, v1);
                float v = (dot11 * dot20 - dot01 * dot21) / denom;
                float w = (dot00 * dot21 - dot01 * dot20) / denom;
                if (any(bvec3(w < 0.0f || w > 1.0f, v < 0.0f || v > 1.0f, w + v > 1.0f))) {
                    rayOrigin = viewCellSamplePoint;
                    rayDir = normalize(s.pos - viewCellSamplePoint);
                    pointFound = true;
                } else {
                    float u = 1.0f - v - w;

                    vec3 c[3];
                    float f = 1.01f / (v + w);
                    c[0] = rayViewCellHitPoints[0] * -0.01 + rayViewCellHitPoints[1] * (v * f) + rayViewCellHitPoints[2] * (w * f);
                    f = 1.01f / (u + w);
                    c[1] = rayViewCellHitPoints[0] * (u * f) + rayViewCellHitPoints[1] * -0.01 + rayViewCellHitPoints[2] * (w * f);
                    f = 1.01f / (u + v);
                    c[2] = rayViewCellHitPoints[0] * (u * f) + rayViewCellHitPoints[1] * (v * f) + rayViewCellHitPoints[2] * -0.01;

                    // Compute corners of the current view face
                    vec3 s0 = viewCell.pos - viewCellRight * viewCell.size.x * 0.5 + viewCellUp * viewCell.size.y * 0.5;
                    vec3 s1 = viewCell.pos + viewCellRight * viewCell.size.x * 0.5 + viewCellUp * viewCell.size.y * 0.5;
                    vec3 s2 = viewCell.pos - viewCellRight * viewCell.size.x * 0.5 - viewCellUp * viewCell.size.y * 0.5;

                    for (int i = 0; i < 3; i++) {
                        // Check if the ray-plane hit point lies within the bounds of the view cell
                        // Project ray-plane hit point on local basis of the view cell
                        float uu = dot(c[i] - s0, s1 - s0);
                        float vv = dot(c[i] - s0, s2 - s0);

                        // Check if the u & v coordinates are within the view cell
                        if (uu >= 0.0 && vv >= 0.0 && uu <= dot(s1 - s0, s1 - s0) && vv <= dot(s2 - s0, s2 - s0)) {
                            rayOrigin = c[i];
                            rayDir = normalize(s.pos - c[i]);
                            pointFound = true;
                            break;
                        }
                    }
                }

                if (pointFound) {
                    count++;
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                    atomicAdd(rsRayCounter, 1);

                    reverseSamplingSample.triangleID = int(hitInfo.w);
                    reverseSamplingSample.rayOrigin = rayOrigin;
                    reverseSamplingSample.rayHitPos = hitInfo.xyz;
                    reverseSamplingSample.pos = s.pos;

                    if (reverseSamplingSample.triangleID != -1) {
                        atomicAdd(rsTriangleCounter, 1);
                        uint index = atomicAdd(triangleCounter, 1);
                        triangleIDOutput[index] = reverseSamplingSample.triangleID;
                        edgeSubdivOutput[index] = reverseSamplingSample;
                        if (length(reverseSamplingSample.rayHitPos - s.pos) < 0.01) {
                            mutatedRayOrigin = reverseSamplingSample.rayOrigin;
                            found = true;
                        }
                    }
                }
            }
        }
    }

    return found;
}

void main() {
    const uint launchIndex = gl_LaunchIDNV.x;
    const uint currentTriangleIndex = uint(floor(launchIndex / 16.0));
    const int numSamplesPerEdge = int(pow(2, MAX_SUBDIVISION_STEPS) + 1);

    vec3 viewCellPos = viewCell.pos;

    // Get two adjacent samples
    uint i = launchIndex;
    Sample s0 = absOutput[i];
    i = (int(mod(launchIndex + 1, 16) + 16 * currentTriangleIndex));
    Sample s1 = absOutput[i];

    // Only subdivide the edge between two adjacent samples if they correspond to
    // different triangles
    if (s0.triangleID != s1.triangleID || s0.triangleID == -1) {
        int index = int(numSamplesPerEdge / 2.0f);

        // Initialize the array storing the generated samples
        Sample samplesOutput[numSamplesPerEdge];
        for (int k = 0; k < numSamplesPerEdge; k++) {
            samplesOutput[k] = Sample(-2, vec3(0.0), vec3(0.0), vec3(0.0));
        }

        samplesOutput[0] = s0;
        samplesOutput[numSamplesPerEdge - 1] = s1;

        vec3 rayOrigin = s0.rayOrigin;

        // Calculate the first sample in the middle of the edge
        vec3 samplePos = (samplesOutput[numSamplesPerEdge - 1].pos + samplesOutput[0].pos) / 2.0f;
        traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, normalize(samplePos - rayOrigin), 100000.0, 0);
        tracedRays++;
        samplesOutput[index] = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);

        vec3 offset = (samplesOutput[numSamplesPerEdge - 1].pos - samplesOutput[0].pos) / 2.0f;
        for (int k = 0; k < MAX_SUBDIVISION_STEPS - 1; k++) {
            offset /= 2.0f;

            // Continue subdivision only if the distance of the new samples are
            // further than a threshold
            if (length(offset) <= SAMPLE_DISTANCE_THRESHOLD) {
                continue;
            }

            for (int m = 0; m < pow(2, k); m++) {
                int currentIndex = index + (index * 2) * m;
                Sample currentSample = samplesOutput[currentIndex];
                if (currentSample.triangleID == -2) {
                    continue;
                }

                // Check if a new sample should be generated and a ray traced, that is if two adjacent
                // samples correspond to different triangles
                if (currentSample.triangleID != samplesOutput[int(currentIndex + index)].triangleID) {
                    vec3 rayOrigin;
                    if (currentSample.triangleID != -1) {
                        rayOrigin = currentSample.rayOrigin;
                    } else {
                        rayOrigin = samplesOutput[int(currentIndex + index)].rayOrigin;
                    }

                    // Calculate the position of a new sample in direction +offset of the current sample
                    vec3 samplePos = currentSample.pos + offset;
                    vec3 rayDir = normalize(samplePos - rayOrigin);
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                    tracedRays++;
                    Sample newSample = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);
                    if (newSample.triangleID != -1) {
                        vec3 mutatedRayOrigin;
                        if (checkDiscontinuity(rayOrigin, rayDir, newSample, mutatedRayOrigin)) {
                            newSample.rayOrigin = mutatedRayOrigin;
                        }
                    }
                    samplesOutput[int(currentIndex + index / 2.0f)] = newSample;
                }

                if (currentSample.triangleID != samplesOutput[int(currentIndex - index)].triangleID) {
                    vec3 rayOrigin;
                    if (currentSample.triangleID != -1) {
                        rayOrigin = currentSample.rayOrigin;
                    } else {
                        rayOrigin = samplesOutput[int(currentIndex - index)].rayOrigin;
                    }

                    // Calculate the position of a new sample in direction -offset of the current sample
                    vec3 samplePos = currentSample.pos - offset;
                    vec3 rayDir = normalize(samplePos - rayOrigin);
                    traceNV(topLevelAS, gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigin, 0.001, rayDir, 100000.0, 0);
                    tracedRays++;
                    Sample newSample = Sample(int(hitInfo.w), rayOrigin, hitInfo.xyz, samplePos);
                    if (newSample.triangleID != -1) {
                        vec3 mutatedRayOrigin;
                        if (checkDiscontinuity(rayOrigin, rayDir, newSample, mutatedRayOrigin)) {
                            newSample.rayOrigin = mutatedRayOrigin;
                        }
                    }
                    samplesOutput[int(currentIndex - index / 2.0f)] = newSample;
                }
            }

            index = int(index / 2.0f);
        }

        // Count the number of triangles that have been found
        const int numSubdivSamples = numSamplesPerEdge - 2;
        uint foundTriangles = 0;
        for (int k = 0; k < numSubdivSamples; k++) {
            #ifdef USE_3D_VIEW_CELL
                if (samplesOutput[k + 1].triangleID >= 0) {
                    foundTriangles++;
                }
            #else
                // In case of a 2d view cell, also check if the found triangle is front-facing
                if (samplesOutput[k + 1].triangleID >= 0 && isTriangleFrontFacing(viewCell.normal, viewCellPos, samplesOutput[k + 1].triangleID)) {
                    foundTriangles++;
                } else {
                    samplesOutput[k + 1].triangleID = -1;
                }
            #endif
        }

        if (foundTriangles > 0) {
            // Add the samples to the output buffer
            uint insertionIndex = atomicAdd(triangleCounter, foundTriangles - 1);
            for (int k = 0, m = 0; k < numSubdivSamples; k++) {
                if (samplesOutput[k + 1].triangleID >= 0) {
                    triangleIDOutput[insertionIndex + m] = samplesOutput[k + 1].triangleID;
                    edgeSubdivOutput[insertionIndex + m] = samplesOutput[k + 1];
                    m++;
                }
            }
        }

        atomicAdd(rayCounter, tracedRays);
    }
}

bool reverseSampling(uint launchIndex, const vec3 rayOrigin, vec3 rayDir, int occludingTriangleID, vec3 samplePos, vec3 hitPoint, out Sample foundSample) {
    bool discontinuityFound = false;
    const float samplePointDistance = length(samplePos - rayOrigin);
    if (occludingTriangleID == -1 || samplePointDistance - length(hitPoint - rayOrigin) > 0.985) {
        foundSample.triangleID = -2;
        discontinuityFound = true;

        // Get view cell coordinate system
        vec3 viewCellSize = vec3(
            length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
            length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
            length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
        ) * 2.0f;
        vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
        vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
        vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
        if (viewCellSize.x == 0.0f) {
            viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
        } else if (viewCellSize.y == 0.0f) {
            viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
        } else if (viewCellSize.z == 0.0f) {
            //viewCellRight = -viewCellRight;
            viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
        }
        vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

        #ifdef USE_3D_VIEW_CELL
            const vec3 faceRights[6] = { viewCellRight, -viewCellNormal, -viewCellRight, viewCellNormal, viewCellRight, viewCellRight };
            const vec3 faceUps[6] = { viewCellUp, viewCellUp, viewCellUp, viewCellUp, -viewCellNormal, viewCellNormal };
            const vec3 faceNormals[6] = { viewCellNormal, viewCellRight, -viewCellNormal, -viewCellRight, viewCellUp, -viewCellUp };
            const vec3 faceSizes[6] = { viewCellSize.xyz, viewCellSize.zyx, viewCellSize.xyz, viewCellSize.zyx, viewCellSize.xzy, viewCellSize.xzy };

            for (int m = 0; m < 6; m++) {
                if (dot(rayDir, faceNormals[m]) < 0) {
                    continue;
                }

                viewCellNormal = faceNormals[m];
                viewCellRight = faceRights[m];
                viewCellUp = faceUps[m];
                viewCellSize = faceSizes[m];
                viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]) + viewCellNormal * viewCellSize.z * 0.5;
        #endif

        vec3 m_x = viewCellRight * viewCellSize.x;
        vec3 m_y = viewCellUp * viewCellSize.y;
        float l1 = length(m_x);
        l1 = l1 * l1;
        float l2 = length(m_y);
        l2 = l2 * l2;
        vec3 frameProjectX = m_x / l1;
        vec3 frameProjectY = m_y / l2;

        vec3 viewCellCorner = viewCellPos - viewCellRight * viewCellSize.x * 0.5 - viewCellUp * viewCellSize.y * 0.5;
        vec3 t1 = rayOrigin - viewCellCorner;
        vec2 uv = vec2(
            dot(t1, frameProjectX),
            dot(t1, frameProjectY)
        );
        if (uv.x < 0) {
            uv.x = 0;
        } else if (uv.x > 1.0f) {
            uv.x = 1.0f;
        }
        if (uv.y < 0) {
            uv.y = 0;
        } else if (uv.y > 1.0f) {
            uv.y = 1.0f;
        }

        vec2 uv_comp = vec2(1.0f - uv.x, 1.0f - uv.y);

        uv = uv * 0.01;
        uv_comp = uv_comp * 0.01;

        int a1 = 2;
        int a2 = 10;
        int a3 = 50;
        int a4 = 100;

        vec3 rayOrigins[16];
        rayOrigins[15] = rayOrigin - a1 * uv.x * m_x;
        rayOrigins[14] = rayOrigin - a2 * uv.x * m_x;
        rayOrigins[13] = rayOrigin - a3 * uv.x * m_x;
        rayOrigins[12] = rayOrigin - a4 * uv.x * m_x;

        rayOrigins[11] = rayOrigin + a1 * uv_comp.x * m_x;
        rayOrigins[10] = rayOrigin + a2 * uv_comp.x * m_x;
        rayOrigins[9] =  rayOrigin + a3 * uv_comp.x * m_x;
        rayOrigins[8] =  rayOrigin + a4 * uv_comp.x * m_x;

        rayOrigins[7] =  rayOrigin - a1 * uv.y * m_y;
        rayOrigins[6] =  rayOrigin - a2 * uv.y * m_y;
        rayOrigins[5] =  rayOrigin - a3 * uv.y * m_y;
        rayOrigins[4] =  rayOrigin - a4 * uv.y * m_y;

        rayOrigins[3] =  rayOrigin + a1 * uv_comp.y * m_y;
        rayOrigins[2] =  rayOrigin + a2 * uv_comp.y * m_y;
        rayOrigins[1] =  rayOrigin + a3 * uv_comp.y * m_y;
        rayOrigins[0] =  rayOrigin + a4 * uv_comp.y * m_y;

        for (int i = 0; i < 16; i++) {
            vec3 rayDirNew = normalize((rayOrigin + (samplePos - rayOrigin)) - rayOrigins[i]);
            traceNV(topLevelAS, gl_RayFlagsCullBackFacingTrianglesNV | gl_RayFlagsOpaqueNV, 0xff, 0, 0, 0, rayOrigins[i], 0.001, rayDirNew, 100000.0, 0);
            atomicAdd(rsRayCounter, 1);

            int triangleID = int(hitInfo.w);
            if (triangleID != -1) {
                bool targetSampleReached = (length(hitInfo.xyz - rayOrigins[i]) - samplePointDistance >= 0.0f) && (foundSample.triangleID == -2);
                if (targetSampleReached) {
                    foundSample = Sample(triangleID, rayOrigins[i], hitInfo.xyz, samplePos);
                }
                int index = storeReverseSample(
                    launchIndex,
                    Sample(triangleID, rayOrigins[i], hitInfo.xyz, samplePos),
                    targetSampleReached
                );
            }
        }
        #ifdef USE_3D_VIEW_CELL
            }
        #endif
    }

    return discontinuityFound;
}

#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 2, set = 0) buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 3, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    mat4 model;
} viewCell;
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
};

layout(binding = 0, set = 1) buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 1, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};
layout(binding = 2, set = 1) buffer absIDOutputBuffer {
    int triangleIDOutput[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

#include "util.glsl"

uint storeReverseSample(uint launchIndex, Sample s, vec3 targetSamplePos) {
    uint index = gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1);
    /*
    if (length(s.rayHitPos - targetSamplePos) < 0.01) {
        triangleIDOutput[index] = absOutput[launchIndex].triangleID;
        absOutput[index] = absOutput[launchIndex];

        triangleIDOutput[launchIndex] = s.triangleID;
        absOutput[launchIndex] = s;
    } else {
        triangleIDOutput[index] = s.triangleID;
        absOutput[index] = s;
    }
    */

    triangleIDOutput[index] = s.triangleID;
    absOutput[index] = s;

    return index;
}

uint tracedRsRays = 0;

#if REVERSE_SAMPLING_METHOD == 0
    #include "reverse_sampling_cpu_impl.rgen"
#elif REVERSE_SAMPLING_METHOD == 1
    #include "reverse_sampling_gvs.rgen"
#elif REVERSE_SAMPLING_METHOD == 2
    #include "reverse_sampling_new.rgen"
#endif

const float DELTA = 0.0001f;

void main() {
    const uint launchIndex = gl_LaunchIDNV.x;
    const uint currentTriangleIndex = uint(floor(launchIndex / 15.0));   // for each triangle 15 rays are shot i.e. for each triangle the shader is invoked 15 times

    const uint currentVertexIndex = uint(mod(floor(launchIndex / 5.0), 3.0));
    const uint nextVertexIndex = uint(mod(currentVertexIndex + 1, 3));

    const uint currentVertexSamplePosIndex = uint(mod(launchIndex, 5));
    const uint nextVertexSamplePosIndex = uint(mod(currentVertexSamplePosIndex + 1, 5));

    Sample s = absWorking[currentTriangleIndex];
    Vertex v[3];
    v[0] = unpackVertexData(indices.i[3 * s.triangleID]);
    v[1] = unpackVertexData(indices.i[3 * s.triangleID + 1]);
    v[2] = unpackVertexData(indices.i[3 * s.triangleID + 2]);
    
    vec3 rayOrigin = s.rayOrigin;

    // Vectors from ray origin to the triangle's vertices
    vec3 vectors[3];
    vectors[0] = v[0].worldPos - rayOrigin;
    vectors[1] = v[1].worldPos - rayOrigin;
    vectors[2] = v[2].worldPos - rayOrigin;

    const uint lastVertexIndex = uint(mod(currentVertexIndex + 2, 3));
    vec3 offsetA = -normalize(
        (v[nextVertexIndex].worldPos - v[currentVertexIndex].worldPos) + (v[lastVertexIndex].worldPos - v[currentVertexIndex].worldPos)
    );
    vec3 offsetB = -normalize(
        (v[currentVertexIndex].worldPos - v[nextVertexIndex].worldPos) + (v[lastVertexIndex].worldPos - v[nextVertexIndex].worldPos)
    );
    vec3 samplePos = mix(
        v[nextVertexIndex].worldPos + offsetB * DELTA,
        v[currentVertexIndex].worldPos + offsetA * DELTA,
        currentVertexSamplePosIndex / 5.0f
    );

    // Get view cell coordinate system
    vec3 viewCellSize = vec3(
        length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
        length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
        length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
    ) * 2.0f;
    vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
    vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
    vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
    if (viewCellSize.x == 0.0f) {
        viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
    } else if (viewCellSize.y == 0.0f) {
        viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
    } else if (viewCellSize.z == 0.0f) {
        //viewCellRight = -viewCellRight;
        viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
    }
    vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);

    vec3 rayDir = normalize(samplePos - rayOrigin);
    #ifndef USE_3D_VIEW_CELL
        if (dot(rayDir, viewCellNormal) > 0) {
    #endif
        // Trace ray
        uint rayFlags = gl_RayFlagsOpaqueNV;
        uint cullMask = 0xff;
        float tmin = 0.001;
        float tmax = 100000.0;
        traceNV(
            topLevelAS,     // acceleration structure
            rayFlags,       // rayFlags
            cullMask,       // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            rayOrigin,      // ray origin
            tmin,           // ray min range
            rayDir,         // ray direction
            tmax,           // ray max range
            0               // payload (location = 0)
        );

        int triangleID = int(hitInfo.w);
        vec3 hitPoint = hitInfo.xyz;
        bool pointBehindViewCell = false;
        int originalABSSampleIndex = -1;
        #ifdef USE_3D_VIEW_CELL
            if (triangleID != -1) {
                vec3 faceNormal = vec3(
                    unpackVertexData(indices.i[3 * triangleID]).normal
                    + unpackVertexData(indices.i[3 * triangleID + 1]).normal
                    + unpackVertexData(indices.i[3 * triangleID + 2]).normal
                ) / 3.0f;
                if (dot(rayDir, faceNormal) >= 0.0f) {
                    triangleID = -1;
                    pointBehindViewCell = true;
                }
            }

            triangleIDOutput[launchIndex] = triangleID;
            absOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
            if (triangleID != -1) {
                atomicAdd(triangleCounter, 1);
            }
        #else
            if (triangleID != -1 && isTriangleFrontFacing(viewCellNormal, viewCellPos, triangleID)) {
                atomicAdd(triangleCounter, 1);
                triangleIDOutput[launchIndex] = triangleID;
                absOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
            } else {
                pointBehindViewCell = true;
                triangleID = -1;
                triangleIDOutput[launchIndex] = -1;
                absOutput[launchIndex] = Sample(-1, rayOrigin, hitPoint, samplePos);
            }
        #endif

        // Reverse sampling
        if (!pointBehindViewCell) {
            #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                int foundReverseSampleIndex = reverseSampling(launchIndex, rayOrigin, rayDir, triangleID, samplePos, hitPoint);
            #elif REVERSE_SAMPLING_METHOD == 1
                int foundReverseSampleIndex = reverseSampling(launchIndex, v, s, rayOrigin, rayDir, triangleID, samplePos, hitPoint);
            #endif
            if (foundReverseSampleIndex != -1) {
                Sample s = absOutput[launchIndex];
                triangleIDOutput[launchIndex] = triangleIDOutput[foundReverseSampleIndex];
                absOutput[launchIndex] = absOutput[foundReverseSampleIndex];
                triangleIDOutput[foundReverseSampleIndex] = s.triangleID;
                absOutput[foundReverseSampleIndex] = s;
            } else {
                uint index = gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1);
                triangleIDOutput[index] = triangleIDOutput[launchIndex];
                absOutput[index] = absOutput[launchIndex];

                triangleIDOutput[launchIndex] = -2;
                absOutput[launchIndex].triangleID = -2;
            }
        }
        
        atomicAdd(rsRayCounter, tracedRsRays);
    #ifndef USE_3D_VIEW_CELL
        } else {
            triangleIDOutput[launchIndex] = -2;
            absOutput[launchIndex] = Sample(-2, vec3(-1.0f),vec3(-1.0f),vec3(-1.0f));
        }
    #endif
}

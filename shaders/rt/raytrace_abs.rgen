#version 460
#extension GL_NV_ray_tracing : require

struct Vertex {
    vec3 pos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;    // TODO: Remove
layout(binding = 2, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 4, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 5, set = 0) readonly buffer haltonPoints {
    vec2 points[];
};
layout(binding = 6, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec2 size;
    vec3 normal;
} viewCell;
layout(binding = 7, set = 0) writeonly buffer foundTrianglesBuffer {
    vec4 foundTriangles[];
};

struct Sample {
    uint triangleID;
    vec3 rayOrigin;
};
layout(binding = 8, set = 0) writeonly buffer rayOriginOutputBuffer {
    Sample rayOriginOutput[];
};

layout(binding = 0, set = 1) writeonly buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 1, set = 1) buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 2, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(location = 0) rayPayloadNV uint hitPrimitiveID;

Vertex unpackVertexData(uint index) {
    vec4 d0 = vertices.v[3 * index + 0];
    vec4 d1 = vertices.v[3 * index + 1];
    vec4 d2 = vertices.v[3 * index + 2];

    Vertex vertex;
    vertex.pos = d0.xyz;
    vertex.normal = vec3(d0.w, d1.xy);
    vertex.color = vec3(d1.zw, d2.x);
    vertex.uv = d2.yz;

    return vertex;
}

void main() {
    // Calculate 1D launch index
    uint launchIndex = gl_LaunchIDNV.x;

    uint i0Index = uint(floor(launchIndex / 9.0));   // for each triangle 9 rays are shot i.e. for each triangle the shader is invoked 9 times
    uint currentVertexIndex = uint(mod(floor(launchIndex / 3.0), 3.0));

    Sample s = absWorking[i0Index];
    Vertex v0 = unpackVertexData(indices.i[3 * s.triangleID + currentVertexIndex]);
    Vertex v1 = unpackVertexData(indices.i[3 * s.triangleID + int(mod(currentVertexIndex + 1, 3))]);
    Vertex v2 = unpackVertexData(indices.i[3 * s.triangleID + int(mod(currentVertexIndex + 2, 3))]);

    vec3 rayOrigin = s.rayOrigin;
    vec3 vec = v0.pos - rayOrigin;

    vec3 d0 = normalize(cross(vec, v2.pos - v0.pos));
    vec3 d1 = normalize(cross(vec, v0.pos - v1.pos));
    vec3 d2;
    if (dot(d0, d1) > 0.0) {
        d2 = normalize(d0 + d1);
    } else {
        d2 = normalize(cross(vec, d1) + cross(d0, vec));
    }

    float epsilon = 5e-5;
    //vec3 p0 = v0.pos + epsilon * length(vec) * d0;
    //vec3 p1 = v0.pos + epsilon * length(vec) * d1;
    //vec3 p2 = v0.pos + epsilon * length(vec) * d2;
    vec3 p;
    uint outerVertexIndex = uint(mod(launchIndex, 3.0));
    if (outerVertexIndex == 0) {        // TODO: Replace if by storing d0,d1,d2 in array and accessing via outerVertexIndex 
        p = v0.pos + epsilon * length(vec) * d0;
    } else if (outerVertexIndex == 1) {
        p = v0.pos + epsilon * length(vec) * d1;
    } else if (outerVertexIndex == 2) {
        p = v0.pos + epsilon * length(vec) * d2;
    }

    vec3 rayDir = normalize(p - rayOrigin);

    // Trace ray
    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    traceNV(
        topLevelAS,     // acceleration structure
        rayFlags,       // rayFlags
        cullMask,       // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        rayOrigin,      // ray origin
        tmin,           // ray min range
        rayDir,         // ray direction
        tmax,           // ray max range
        0               // payload (location = 0)
    );

    absOutput[launchIndex] = Sample(hitPrimitiveID, rayOrigin);

/*
    if (launchIndex == 0) {
        absOutput[launchIndex] = Sample(hitPrimitiveID, rayOrigin);

        absOutput[launchIndex + 1] = Sample(hitPrimitiveID, v0.pos);
        absOutput[launchIndex + 2] = Sample(hitPrimitiveID, v1.pos);
        absOutput[launchIndex + 3] = Sample(hitPrimitiveID, v2.pos);

        absOutput[launchIndex + 4] = Sample(hitPrimitiveID, v0.pos + epsilon * length(vec) * d0);
        absOutput[launchIndex + 5] = Sample(hitPrimitiveID, v0.pos + epsilon * length(vec) * d1);
        absOutput[launchIndex + 6] = Sample(hitPrimitiveID, v0.pos + epsilon * length(vec) * d2);
    }
    */
    
    //absOutput[3 * launchIndex + 0] = hitValue.x;
    //absOutput[3 * launchIndex + 1] = hitValue.y;
    //absOutput[3 * launchIndex + 2] = hitValue.z;


    /*
    absOutput[3 * launchIndex + 0] = i0Index;
    absOutput[3 * launchIndex + 1] = i0Index;
    absOutput[3 * launchIndex + 2] = i0Index;
    */
}

/*
absOutput[3 * launchIndex + 0] = foundTriangles[3 * launchIndex + 0];
absOutput[3 * launchIndex + 1] = uint(v0.pos.x);
absOutput[3 * launchIndex + 2] = 3;
*/

//imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(1.0));  // TODO: This is unused

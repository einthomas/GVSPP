#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 2, set = 0) readonly buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 3, set = 0) readonly buffer Indices {
    uint i[];
} indices;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec3 size;
    vec3 right;
    vec3 up;
    vec3 normal;
} viewCell;
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
    uint pvsSize;
};

layout(binding = 9, set = 0) buffer setBuffer {
    int set[];
};
layout(binding = 10, set = 0) uniform pvsBufferCapacity {
    int pvsCapacity;
};

layout(binding = 6, set = 0) buffer randomSamplingOutputBuffer {
    Sample randomSamplingOutput[];
};

layout(binding = 0, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

#include "util.glsl"
#include "gpuHashSet.glsl"

int storeReverseSample(uint launchIndex, Sample s, bool targetSampleReached) {
    int index = -1;
    
    #ifdef USE_RECURSIVE_EDGE_SUBDIVISION
        if (targetSampleReached) {
            if (insert(randomSamplingOutput[launchIndex].triangleID)) {
                index = int(gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1));
                randomSamplingOutput[index] = randomSamplingOutput[launchIndex];
            }
            randomSamplingOutput[launchIndex] = s;
        } else {
            if (insert(s.triangleID)) {
                randomSamplingOutput[int(gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1))] = s;
            }
        }
    #else
        if (insert(s.triangleID)) {
            atomicAdd(rsTriangleCounter, 1);
            randomSamplingOutput[int(atomicAdd(triangleCounter, 1))] = s;
        }
    #endif
    
    return index;
}

#if REVERSE_SAMPLING_METHOD == 0
    #include "reverse_sampling_cpu_impl.rgen"
#elif REVERSE_SAMPLING_METHOD == 1
    #include "reverse_sampling_gvs.rgen"
#elif REVERSE_SAMPLING_METHOD == 2
    #include "reverse_sampling_new.rgen"
#endif

void main() {
    const uint launchIndex = gl_LaunchIDNV.x;
    const uint currentTriangleIndex = uint(floor(launchIndex / float((ABS_NUM_SAMPLES_PER_EDGE + 3) * 3)));   // for each triangle ABS_NUM_SAMPLES_PER_EDGE * 3 rays are shot i.e. for each triangle the shader is invoked ABS_NUM_SAMPLES_PER_EDGE * 3 times

    const uint currentVertexIndex = uint(mod(floor(launchIndex / float((ABS_NUM_SAMPLES_PER_EDGE + 3))), 3));
    const uint nextVertexIndex = uint(mod(currentVertexIndex + 1, 3));
    const uint lastVertexIndex = uint(mod(currentVertexIndex + 2, 3));

    const uint currentVertexSamplePosIndex = uint(mod(launchIndex, ABS_NUM_SAMPLES_PER_EDGE));
    const uint nextVertexSamplePosIndex = uint(mod(currentVertexSamplePosIndex + 1, ABS_NUM_SAMPLES_PER_EDGE));

    const Sample s = absWorking[currentTriangleIndex];

    const vec3 rayOrigin = s.rayOrigin;

    const vec3 currentWP = getVertexWorldPos(indices.i[3 * s.triangleID + currentVertexIndex]);
    const vec3 nextWP = getVertexWorldPos(indices.i[3 * s.triangleID + nextVertexIndex]);
    const vec3 lastWP = getVertexWorldPos(indices.i[3 * s.triangleID + lastVertexIndex]);

    vec3 samplePos;
    const uint currentEdgeSampleIndex = uint(mod(launchIndex, (ABS_NUM_SAMPLES_PER_EDGE + 3)));
    const vec3 vec = normalize(currentWP - rayOrigin);
    if (currentEdgeSampleIndex < 3) {
        vec3 d[3];
        d[0] = normalize(cross(vec, nextWP - currentWP));
        d[1] = normalize(cross(vec, currentWP - lastWP));

        if (dot(d[0], d[1]) < 0) {
            d[2] = normalize(d[0] + d[1]);
        } else {
            d[2] = normalize(normalize(d[1] + cross(vec, d[1])) + normalize(d[0] + cross(d[0], vec)));
        }

        samplePos = currentWP + ABS_DELTA * d[currentEdgeSampleIndex];
    } else {
        /*
        vec3 offsetA = -normalize((nextWP - currentWP) + (lastWP - currentWP));
        vec3 offsetB = -normalize((currentWP - nextWP) + (lastWP - nextWP));
        float absDelta = mod(currentVertexSamplePosIndex, 2.0f) == 0 ? ABS_DELTA : ABS_DELTA * 0.1f;
        samplePos = mix(
            nextWP + offsetB * absDelta,
            currentWP + offsetA * absDelta,
            currentVertexSamplePosIndex / float(ABS_NUM_SAMPLES_PER_EDGE)
        );
        */
        
        samplePos = mix(
            nextWP + ABS_DELTA * normalize(cross(normalize(nextWP - rayOrigin), nextWP - currentWP)),// + offsetA * absDelta,
            currentWP + ABS_DELTA * normalize(cross(normalize(currentWP - rayOrigin), nextWP - currentWP)),// + offsetB * absDelta,
            ((currentEdgeSampleIndex - 2)) / float(ABS_NUM_SAMPLES_PER_EDGE + 1)
        );
    }

    vec3 rayDir = normalize(samplePos - rayOrigin);
    
    #ifndef USE_3D_VIEW_CELL
        // Get view cell coordinate system
        vec3 viewCellSize = viewCell.size * 2.0f;
        vec3 viewCellRight = viewCell.right;
        vec3 viewCellUp = viewCell.up;
        vec3 viewCellNormal = viewCell.normal;
        vec3 viewCellPos = viewCell.pos;
        
        if (dot(rayDir, viewCellNormal) > 0) {
    #endif
        // Trace ray
        uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV | gl_RayFlagsOpaqueNV;
        uint cullMask = 0xff;
        float tmin = 0.001;
        float tmax = 100000.0;
        traceNV(
            topLevelAS,     // acceleration structure
            rayFlags,       // rayFlags
            cullMask,       // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            rayOrigin,      // ray origin
            tmin,           // ray min range
            rayDir,         // ray direction
            tmax,           // ray max range
            0               // payload (location = 0)
        );

        int triangleID = int(hitInfo.w);
        vec3 hitPoint = hitInfo.xyz;
        #ifdef USE_RECURSIVE_EDGE_SUBDIVISION
            // If the recursive edge subdivision strategy is used, samples are stored in randomSamplingOutput at index
            // launchIndex. Each two samples surrounding the same triangle form an edge, which is recursively
            // subdivided if rays through such samples hit different triangles. The subdivision is performed
            // in the raytrace_subdiv.rgen shader

            #ifdef USE_3D_VIEW_CELL
                randomSamplingOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
                if (triangleID != -1) {
                    atomicAdd(triangleCounter, 1);
                }
            #else
                if (triangleID != -1) {
                    atomicAdd(triangleCounter, 1);
                    randomSamplingOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
                } else {
                    triangleID = -1;
                    randomSamplingOutput[launchIndex] = Sample(-1, rayOrigin, hitPoint, samplePos);
                }
            #endif

            // Reverse sampling
            Sample foundSample;
            #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                bool discontinuityFound = reverseSampling(launchIndex, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
            #elif REVERSE_SAMPLING_METHOD == 1
                vec3 v[3] = { currentWP, nextWP, lastWP };
                bool discontinuityFound = reverseSampling(launchIndex, v, s, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
            #endif

            // If a discontinuity has been found but no ray was traced through the original sample, the
            // edge that would be subdivided would span from the current triangle, for which ABS samples
            // are generated, to the sample that lies on the occluding triangle that caused the discontinuity.
            // This is not intended, therefore the triangleID of the sample at launchIndex is set to -2
            if (discontinuityFound && foundSample.triangleID == -2 && triangleID != -1) {
                if (insert(randomSamplingOutput[launchIndex].triangleID)) {
                    uint index = gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1);
                    randomSamplingOutput[index] = randomSamplingOutput[launchIndex];
                }
                randomSamplingOutput[launchIndex].triangleID = -2;
            }
        #else
            // Reverse sampling
            Sample foundSample;
            #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                reverseSampling(launchIndex, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
            #elif REVERSE_SAMPLING_METHOD == 1
                vec3 v[3] = { currentWP, nextWP, lastWP };
                reverseSampling(launchIndex, v, s, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
            #endif
            
            if (triangleID != -1 && insert(triangleID)) {
                uint index = atomicAdd(triangleCounter, 1);
                randomSamplingOutput[index] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
            }
            /*
            if (triangleID != -1 && s.triangleID == 597294) {
                insert(triangleID);
                uint index = atomicAdd(triangleCounter, 1);
                randomSamplingOutput[index] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
            }
            */
        #endif
    #ifndef USE_3D_VIEW_CELL
        } else {
            #ifdef USE_RECURSIVE_EDGE_SUBDIVISION
                randomSamplingOutput[launchIndex] = Sample(-2, vec3(-1.0f),vec3(-1.0f),vec3(-1.0f));
            #endif
        }
    #endif
}

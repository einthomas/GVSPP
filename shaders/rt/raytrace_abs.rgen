#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 2, set = 0) readonly buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 3, set = 0) readonly buffer Indices {
    uint i[];
} indices;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    mat4 model;
} viewCell;
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
    uint pvsSize;
};

layout(binding = 9, set = 0) buffer setBuffer {
    int set[];
};
layout(binding = 10, set = 0) uniform pvsBufferCapacity {
    int pvsCapacity;
};

layout(binding = 6, set = 0) buffer randomSamplingOutputBuffer {
    Sample randomSamplingOutput[];
};

layout(binding = 0, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

#include "util.glsl"
#include "gpuHashSet.glsl"

int storeReverseSample(uint launchIndex, Sample s, bool targetSampleReached) {
    int index = -1;
    
    #ifdef USE_RECURSIVE_EDGE_SUBDIVISION
        if (targetSampleReached) {
            if (insert(randomSamplingOutput[launchIndex].triangleID)) {
                index = int(gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1));
                randomSamplingOutput[index] = randomSamplingOutput[launchIndex];
            }
            randomSamplingOutput[launchIndex] = s;
        } else {
            if (insert(s.triangleID)) {
                randomSamplingOutput[int(gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1))] = s;
            }
        }
    #else
        if (insert(s.triangleID)) {
            atomicAdd(rsTriangleCounter, 1);
            randomSamplingOutput[int(atomicAdd(triangleCounter, 1))] = s;
        }
    #endif
    
    return index;
}

#if REVERSE_SAMPLING_METHOD == 0
    #include "reverse_sampling_cpu_impl.rgen"
#elif REVERSE_SAMPLING_METHOD == 1
    #include "reverse_sampling_gvs.rgen"
#elif REVERSE_SAMPLING_METHOD == 2
    #include "reverse_sampling_new.rgen"
#endif

void main() {
    const uint launchIndex = gl_LaunchIDNV.x;
    const uint currentTriangleIndex = uint(floor(launchIndex / float(ABS_NUM_SAMPLES_PER_EDGE * 3)));   // for each triangle 15 rays are shot i.e. for each triangle the shader is invoked 15 times

    const uint currentVertexIndex = uint(mod(floor(launchIndex / float(ABS_NUM_SAMPLES_PER_EDGE)), 3.0));
    const uint nextVertexIndex = uint(mod(currentVertexIndex + 1, 3));

    const uint currentVertexSamplePosIndex = uint(mod(launchIndex, ABS_NUM_SAMPLES_PER_EDGE));
    const uint nextVertexSamplePosIndex = uint(mod(currentVertexSamplePosIndex + 1, ABS_NUM_SAMPLES_PER_EDGE));

    const Sample s = absWorking[currentTriangleIndex];

    const vec3 rayOrigin = s.rayOrigin;

    const uint lastVertexIndex = uint(mod(currentVertexIndex + 2, 3));

    const vec3 nextWP = unpackVertexData(indices.i[3 * s.triangleID + nextVertexIndex]).worldPos;
    const vec3 currentWP = unpackVertexData(indices.i[3 * s.triangleID + currentVertexIndex]).worldPos;
    const vec3 lastWP = unpackVertexData(indices.i[3 * s.triangleID + lastVertexIndex]).worldPos;
    vec3 offsetA = -normalize((nextWP - currentWP) + (lastWP - currentWP));
    vec3 offsetB = -normalize((currentWP - nextWP) + (lastWP - nextWP));
    vec3 samplePos = mix(
        nextWP + offsetB * ABS_DELTA,
        currentWP + offsetA * ABS_DELTA,
        currentVertexSamplePosIndex / float(ABS_NUM_SAMPLES_PER_EDGE)
    );

    vec3 rayDir = normalize(samplePos - rayOrigin);
    
    #ifndef USE_3D_VIEW_CELL
        // Get view cell coordinate system
        vec3 viewCellSize = vec3(
            length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
            length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
            length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
        ) * 2.0f;
        vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
        vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
        vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
        if (viewCellSize.x == 0.0f) {
            viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
        } else if (viewCellSize.y == 0.0f) {
            viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
        } else if (viewCellSize.z == 0.0f) {
            //viewCellRight = -viewCellRight;
            viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
        }
        vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);
        
        if (dot(rayDir, viewCellNormal) > 0) {
    #endif
        // Trace ray
        uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV | gl_RayFlagsOpaqueNV;
        uint cullMask = 0xff;
        float tmin = 0.001;
        float tmax = 100000.0;
        traceNV(
            topLevelAS,     // acceleration structure
            rayFlags,       // rayFlags
            cullMask,       // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            rayOrigin,      // ray origin
            tmin,           // ray min range
            rayDir,         // ray direction
            tmax,           // ray max range
            0               // payload (location = 0)
        );

        int triangleID = int(hitInfo.w);
        vec3 hitPoint = hitInfo.xyz;
        bool pointBehindViewCell = false;
        #ifdef USE_RECURSIVE_EDGE_SUBDIVISION
            // If the recursive edge subdivision strategy is used, samples are stored in randomSamplingOutput at index
            // launchIndex. Each two samples surrounding the same triangle form an edge, which is recursively
            // subdivided if rays through such samples hit different triangles. The subdivision is performed
            // in the raytrace_subdiv.rgen shader

            #ifdef USE_3D_VIEW_CELL
                randomSamplingOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
                if (triangleID != -1) {
                    atomicAdd(triangleCounter, 1);
                }
            #else
                if (triangleID != -1) {
                    atomicAdd(triangleCounter, 1);
                    randomSamplingOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
                } else {
                    pointBehindViewCell = true;
                    triangleID = -1;
                    randomSamplingOutput[launchIndex] = Sample(-1, rayOrigin, hitPoint, samplePos);
                }
            #endif

            if (!pointBehindViewCell) {
                // Reverse sampling
                Sample foundSample;
                #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                    bool discontinuityFound = reverseSampling(launchIndex, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
                #elif REVERSE_SAMPLING_METHOD == 1
                    bool discontinuityFound = reverseSampling(launchIndex, v, s, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
                #endif

                // If a discontinuity has been found but no ray was traced through the original sample, the
                // edge that would be subdivided would span from the current triangle, for which ABS samples
                // are generated, to the sample that lies on the occluding triangle that caused the discontinuity.
                // This is not intended, therefore the triangleID of the sample at launchIndex is set to -2
                if (discontinuityFound && foundSample.triangleID == -2) {
                    if (insert(randomSamplingOutput[launchIndex].triangleID)) {
                        uint index = gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1);
                        randomSamplingOutput[index] = randomSamplingOutput[launchIndex];
                    }
                    randomSamplingOutput[launchIndex].triangleID = -2;
                }
            }
        #else
            if (!pointBehindViewCell) {
                // Reverse sampling
                Sample foundSample;
                #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                    reverseSampling(launchIndex, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
                #elif REVERSE_SAMPLING_METHOD == 1
                    reverseSampling(launchIndex, v, s, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
                #endif

                if (triangleID != -1 && insert(triangleID)) {
                    uint index = atomicAdd(triangleCounter, 1);
                    randomSamplingOutput[index] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
                }
            }
        #endif
    #ifndef USE_3D_VIEW_CELL
        } else {
            #ifdef USE_RECURSIVE_EDGE_SUBDIVISION
                randomSamplingOutput[launchIndex] = Sample(-2, vec3(-1.0f),vec3(-1.0f),vec3(-1.0f));
            #endif
        }
    #endif
}

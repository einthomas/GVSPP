#version 460
#extension GL_NV_ray_tracing : require

#include "defines.glsl"

struct Vertex {
    vec3 pos;
    vec3 worldPos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};
struct Sample {
    int triangleID;
    vec3 rayOrigin;
    vec3 rayHitPos;
    vec3 pos;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 2, set = 0) buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 3, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 4, set = 0) readonly buffer haltonPoints {
    float points[];
};
layout(binding = 5, set = 0) uniform viewCellProperties {
    mat4 model;
} viewCell;
layout(binding = 8, set = 0) buffer triangleCounterBuffer {
    uint triangleCounter;
    uint rsTriangleCounter;
    uint rayCounter;
    uint rsRayCounter;
    uint pvsSize;
};

layout(binding = 9, set = 0) buffer setBuffer {
    int set[];
};
layout(binding = 11, set = 0) uniform pvsBufferCapacity {
    int pvsCapacity;
};

layout(binding = 0, set = 1) buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 1, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};
layout(binding = 2, set = 1) buffer absIDOutputBuffer {
    int triangleIDOutput[];
};

layout(location = 0) rayPayloadNV vec4 hitInfo;

#include "util.glsl"
#include "gpuHashSet.glsl"

int storeReverseSample(uint launchIndex, Sample s, bool targetSampleReached) {
    int index = -1;

    if (targetSampleReached) {
        if (insert(absOutput[launchIndex].triangleID)) {
            index = int(gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1));
            absOutput[index] = absOutput[launchIndex];
        }
        absOutput[launchIndex] = s;
    } else {
        if (insert(s.triangleID)) {
            absOutput[int(gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1))] = s;
        }
    }

    /*
    if (length(s.rayHitPos - targetSamplePos) < 0.01) {
        triangleIDOutput[index] = absOutput[launchIndex].triangleID;
        absOutput[index] = absOutput[launchIndex];

        triangleIDOutput[launchIndex] = s.triangleID;
        absOutput[launchIndex] = s;
    } else {
        triangleIDOutput[index] = s.triangleID;
        absOutput[index] = s;
    }
    */

    //triangleIDOutput[index] = s.triangleID;
    //absOutput[index] = s;

    return index;
}

uint tracedRsRays = 0;

#if REVERSE_SAMPLING_METHOD == 0
    #include "reverse_sampling_cpu_impl.rgen"
#elif REVERSE_SAMPLING_METHOD == 1
    #include "reverse_sampling_gvs.rgen"
#elif REVERSE_SAMPLING_METHOD == 2
    #include "reverse_sampling_new.rgen"
#endif

const float DELTA = 0.0001f;

void main() {
    const uint launchIndex = gl_LaunchIDNV.x;
    const uint currentTriangleIndex = uint(floor(launchIndex / 15.0));   // for each triangle 15 rays are shot i.e. for each triangle the shader is invoked 15 times

    const uint currentVertexIndex = uint(mod(floor(launchIndex / 5.0), 3.0));
    const uint nextVertexIndex = uint(mod(currentVertexIndex + 1, 3));

    const uint currentVertexSamplePosIndex = uint(mod(launchIndex, 5));
    const uint nextVertexSamplePosIndex = uint(mod(currentVertexSamplePosIndex + 1, 5));

    Sample s = absWorking[currentTriangleIndex];
    Vertex v[3];
    v[0] = unpackVertexData(indices.i[3 * s.triangleID]);
    v[1] = unpackVertexData(indices.i[3 * s.triangleID + 1]);
    v[2] = unpackVertexData(indices.i[3 * s.triangleID + 2]);
    
    vec3 rayOrigin = s.rayOrigin;

    // Vectors from ray origin to the triangle's vertices
    vec3 vectors[3];
    vectors[0] = v[0].worldPos - rayOrigin;
    vectors[1] = v[1].worldPos - rayOrigin;
    vectors[2] = v[2].worldPos - rayOrigin;

    const uint lastVertexIndex = uint(mod(currentVertexIndex + 2, 3));
    vec3 offsetA = -normalize(
        (v[nextVertexIndex].worldPos - v[currentVertexIndex].worldPos) + (v[lastVertexIndex].worldPos - v[currentVertexIndex].worldPos)
    );
    vec3 offsetB = -normalize(
        (v[currentVertexIndex].worldPos - v[nextVertexIndex].worldPos) + (v[lastVertexIndex].worldPos - v[nextVertexIndex].worldPos)
    );
    vec3 samplePos = mix(
        v[nextVertexIndex].worldPos + offsetB * DELTA,
        v[currentVertexIndex].worldPos + offsetA * DELTA,
        currentVertexSamplePosIndex / 5.0f
    );

    vec3 rayDir = normalize(samplePos - rayOrigin);
    
    #ifndef USE_3D_VIEW_CELL
        // Get view cell coordinate system
        vec3 viewCellSize = vec3(
            length(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2])),
            length(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2])),
            length(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]))
        ) * 2.0f;
        vec3 viewCellRight = normalize(vec3(viewCell.model[0][0], viewCell.model[0][1], viewCell.model[0][2]));
        vec3 viewCellUp = normalize(vec3(viewCell.model[1][0], viewCell.model[1][1], viewCell.model[1][2]));
        vec3 viewCellNormal = normalize(vec3(viewCell.model[2][0], viewCell.model[2][1], viewCell.model[2][2]));
        if (viewCellSize.x == 0.0f) {
            viewCellRight = normalize(cross(viewCellUp, viewCellNormal));
        } else if (viewCellSize.y == 0.0f) {
            viewCellUp = normalize(cross(viewCellNormal, viewCellRight));
        } else if (viewCellSize.z == 0.0f) {
            //viewCellRight = -viewCellRight;
            viewCellNormal = normalize(cross(viewCellRight, viewCellUp));
        }
        vec3 viewCellPos = vec3(viewCell.model[3][0], viewCell.model[3][1], viewCell.model[3][2]);
        
        if (dot(rayDir, viewCellNormal) > 0) {
    #endif
        // Trace ray
        uint rayFlags = gl_RayFlagsOpaqueNV;
        uint cullMask = 0xff;
        float tmin = 0.001;
        float tmax = 100000.0;
        traceNV(
            topLevelAS,     // acceleration structure
            rayFlags,       // rayFlags
            cullMask,       // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            rayOrigin,      // ray origin
            tmin,           // ray min range
            rayDir,         // ray direction
            tmax,           // ray max range
            0               // payload (location = 0)
        );

        int triangleID = int(hitInfo.w);
        vec3 hitPoint = hitInfo.xyz;
        bool pointBehindViewCell = false;
        #ifdef USE_3D_VIEW_CELL
            if (triangleID != -1) {
                vec3 faceNormal = vec3(
                    unpackVertexData(indices.i[3 * triangleID]).normal
                    + unpackVertexData(indices.i[3 * triangleID + 1]).normal
                    + unpackVertexData(indices.i[3 * triangleID + 2]).normal
                ) / 3.0f;
                if (dot(rayDir, faceNormal) >= 0.0f) {
                    triangleID = -1;
                    pointBehindViewCell = true;
                }
            }

            //triangleIDOutput[launchIndex] = triangleID;
            absOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
            if (triangleID != -1) {
                atomicAdd(triangleCounter, 1);
            }
        #else
            if (triangleID != -1 && isTriangleFrontFacing(viewCellNormal, viewCellPos, triangleID)) {
                atomicAdd(triangleCounter, 1);
                absOutput[launchIndex] = Sample(triangleID, rayOrigin, hitPoint, samplePos);
            } else {
                pointBehindViewCell = true;
                triangleID = -1;
                //triangleIDOutput[launchIndex] = -1;
                absOutput[launchIndex] = Sample(-1, rayOrigin, hitPoint, samplePos);
            }
        #endif

        // Reverse sampling
        if (!pointBehindViewCell) {
            
            Sample foundSample;
            #if REVERSE_SAMPLING_METHOD == 0 || REVERSE_SAMPLING_METHOD == 2
                bool discontinuityFound = reverseSampling(launchIndex, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
            #elif REVERSE_SAMPLING_METHOD == 1
                bool discontinuityFound = reverseSampling(launchIndex, v, s, rayOrigin, rayDir, triangleID, samplePos, hitPoint, foundSample);
            #endif
            if (discontinuityFound && foundSample.triangleID == -2) {
                if (insert(absOutput[launchIndex].triangleID)) {
                    uint index = gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1);
                    absOutput[index] = absOutput[launchIndex];
                }
                absOutput[launchIndex].triangleID = -2;
            }
            



            /*
            if (foundReverseSampleIndex >= 0) {
                Sample s = absOutput[launchIndex];
                //triangleIDOutput[launchIndex] = triangleIDOutput[foundReverseSampleIndex];
                absOutput[launchIndex] = absOutput[foundReverseSampleIndex];
                //triangleIDOutput[foundReverseSampleIndex] = s.triangleID;
                absOutput[foundReverseSampleIndex] = s;
            } else if (foundReverseSampleIndex == -1) {
                uint index = gl_LaunchSizeNV.x + atomicAdd(rsTriangleCounter, 1);
                //triangleIDOutput[index] = triangleIDOutput[launchIndex];
                absOutput[index] = absOutput[launchIndex];

                //triangleIDOutput[launchIndex] = -2;
                absOutput[launchIndex].triangleID = -2;
            }
            */
        }
        
        atomicAdd(rsRayCounter, tracedRsRays);
    #ifndef USE_3D_VIEW_CELL
        } else {
            //triangleIDOutput[launchIndex] = -2;
            absOutput[launchIndex] = Sample(-2, vec3(-1.0f),vec3(-1.0f),vec3(-1.0f));
        }
    #endif
}

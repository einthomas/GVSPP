#version 460
#extension GL_NV_ray_tracing : require

struct Vertex {
    vec3 pos;
    vec3 normal;
    vec3 color;
    vec2 uv;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;    // TODO: Remove
layout(binding = 2, set = 0) uniform cameraProperties {
    mat4 model;
    mat4 view;
    mat4 projection;
} camera;
layout(binding = 4, set = 0) buffer Indices {
    uint i[];
} indices;
layout(binding = 5, set = 0) readonly buffer haltonPoints {
    vec2 points[];
};
layout(binding = 6, set = 0) uniform viewCellProperties {
    vec3 pos;
    vec2 size;
    vec3 normal;
} viewCell;
layout(binding = 7, set = 0) writeonly buffer foundTrianglesBuffer {
    vec4 foundTriangles[];
};

struct Sample {
    uint triangleID;
    vec3 rayOrigin;
};
layout(binding = 8, set = 0) writeonly buffer rayOriginOutputBuffer {
    Sample rayOriginOutput[];
};

layout(binding = 0, set = 1) writeonly buffer absOutputBuffer {
    Sample absOutput[];
};
layout(binding = 1, set = 1) buffer Vertices {
    vec4 v[];
} vertices;
layout(binding = 2, set = 1) readonly buffer absWorkingBuffer {
    Sample absWorking[];
};

layout(location = 0) rayPayloadNV uint hitPrimitiveID;

Vertex unpackVertexData(uint index) {
    vec4 d0 = vertices.v[3 * index + 0];
    vec4 d1 = vertices.v[3 * index + 1];
    vec4 d2 = vertices.v[3 * index + 2];

    Vertex vertex;
    vertex.pos = d0.xyz;
    vertex.normal = vec3(d0.w, d1.xy);
    vertex.color = vec3(d1.zw, d2.x);
    vertex.uv = d2.yz;

    return vertex;
}

void main() {
    // Calculate 1D launch index
    uint launchIndex = gl_LaunchIDNV.x;

    uint i0Index = uint(floor(launchIndex / 9.0));   // for each triangle 9 rays are shot i.e. for each triangle the shader is invoked 9 times
    uint currentVertexIndex = uint(mod(floor(launchIndex / 3.0), 3.0));

    Sample s = absWorking[i0Index];
    Vertex v0 = unpackVertexData(indices.i[3 * s.triangleID + currentVertexIndex]);
    Vertex v1 = unpackVertexData(indices.i[3 * s.triangleID + int(mod(currentVertexIndex + 1, 3))]);
    Vertex v2 = unpackVertexData(indices.i[3 * s.triangleID + int(mod(currentVertexIndex + 2, 3))]);

    vec3 rayOrigin = s.rayOrigin;
    vec3 vec = v0.pos - rayOrigin;

    vec3 directions[3];
    directions[0] = normalize(cross(vec, v2.pos - v0.pos));
    directions[1] = normalize(cross(vec, v0.pos - v1.pos));
    if (dot(directions[0], directions[1]) > 0.0) {
        directions[2] = normalize(directions[0] + directions[1]);
    } else {
        directions[2] = normalize(cross(vec, directions[1]) + cross(directions[0], vec));
    }

    float epsilon = 5e-5;
    uint outerVertexIndex = uint(mod(launchIndex, 3.0));
    vec3 p = v0.pos + epsilon * length(vec) * directions[outerVertexIndex];

    vec3 rayDir = normalize(p - rayOrigin);

    // Trace ray
    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    traceNV(
        topLevelAS,     // acceleration structure
        rayFlags,       // rayFlags
        cullMask,       // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        rayOrigin,      // ray origin
        tmin,           // ray min range
        rayDir,         // ray direction
        tmax,           // ray max range
        0               // payload (location = 0)
    );

    absOutput[launchIndex] = Sample(hitPrimitiveID, rayOrigin);
}
